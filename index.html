<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Controlled Maze - HMI Präsentation</title>

    <link rel="icon" href="./assets/logo-small.svg" type="image/x-icon">

    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=Fira+Code:wght@400;500&display=swap"
        rel="stylesheet">

    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

    <link rel="stylesheet" href="styles.css?v=2.0">
</head>

<body>

    <div class="presentation-container">

        <div class="slide active split-content">
            <div class="content-panel">
                <h1>Voice Controlled Maze</h1>
                <p>Human Machine Interaction (HMI) Projekt</p>
                <p>Eine moderne Webanwendung, die Sprachsteuerung mit klassischen Labyrinth-Algorithmen verbindet.</p>

                <div class="authors">
                    <p><strong>Entwickelt von:</strong><br>
                        Juan Fernando Lenis Serna<br>
                        Ayman Lahseb</p>
                    <p class="print-only-link">
                        <strong>Präsentation Link:</strong> <a href="https://lenis-jf.github.io/voice-maze-presentation/">https://lenis-jf.github.io/voice-maze-presentation/</a>
                    </p>
                </div>
            </div>
            <div class="visual-panel">
                <div class="qr-panel">
                    <img src="https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=https://lenis-jf.github.io/voice-maze-presentation/"
                        class="qr-img" alt="Präsentation QR">
                    <p class="qr-caption">Scannen für Slides</p>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>Projektziele & Umfang</h1>
                <h2>Das Hauptziel</h2>
                <p>Entwicklung einer <strong>barrierefreien, modernen und responsiven</strong> Webanwendung für
                    jedermann.</p>

                <h2>Kernfunktionen</h2>
                <ul>
                    <li><strong>Zufällige Generierung:</strong> Jedes Spiel ist einzigartig (Algorithmus-basiert).</li>
                    <li><strong>Anpassbar:</strong> Benutzerdefiniertes Raster (Grid-Size).</li>
                    <li><strong>Visuelles Feedback:</strong> Konstante Rückmeldung über den Spielstatus.</li>
                    <li><strong>Engagement:</strong> Fördert kontinuierliche Verbesserung des Spielers.</li>
                </ul>

                <h2>Steuerung & Accessibility</h2>
                <p>Unterstützt multimodale Eingaben (Tastatur & Stimme). Auf Mobilgeräten kommen <strong>Floating
                        Buttons</strong> zum Einsatz, um die Bewegung des Charakters präzise zu steuern.</p>
            </div>
            <div class="visual-panel">
                <div class="qr-panel no-border">
                    <i class="fas fa-universal-access icon-large"></i>
                    <p style="margin-top:20px; text-align:center;">Unterstützung der Barrierefreiheit durch universelle
                        Eingabemethoden.</p>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>Warum ist das ein gutes HMI-Projekt?</h1>

                <p><strong>Natürliche Interaktion (NUI):</strong><br>
                    Ermöglicht durch Sprachsteuerung. Die Schnittstelle passt sich dem Menschen an, nicht umgekehrt.</p>

                <p><strong>Software-Ergonomie:</strong><br>
                    Das System ist leicht erlernbar und intuitiv zu bedienen. Es erfordert keine komplexe Einarbeitung.
                </p>

                <p><strong>System-Feedback & Status:</strong><br>
                    Auch wenn die Sprachverarbeitung Zeit benötigt, gibt das System visuelles Feedback (z.B.
                    "Listening..."), um die Latenz für den Nutzer transparent zu machen.</p>

                <p><strong>Multimodale Eingabe:</strong><br>
                    Kombination aus diskreten (Tastatur/Touch) und kontinuierlichen (Sprache) Eingabemethoden.</p>
            </div>
            <div class="visual-panel">
                <div class="screenshot-panel">
                    <img src="assets/game-screenshot.png" alt="Game Screenshot" class="screenshot-img">
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>Implementierte Technologien</h1>

                <h2>Frontend: React.js</h2>
                <p>Da die Webanwendung stark von konstantem I/O und schnellen Status-Updates abhängt, haben wir uns für
                    <strong>React.js</strong> entschieden. Es verwaltet den DOM effizient durch das Virtual DOM.
                </p>

                <h2>Styling: SCSS</h2>
                <p>Für das Design nutzen wir <strong>SCSS</strong> für ein modulares und strukturiertes Styling.</p>

                <h2>Paket Manager: NPM</h2>
                <p><strong>NPM</strong> ermöglicht die einfache Integration externer Bibliotheken und Tools.</p>

                <h2>Versionierung: Git</h2>
                <p><strong>Git</strong> sorgt für Versionskontrolle und Nachverfolgbarkeit für Teamarbeit.</p>

                <h2>Hosting: GitHub Pages</h2>
                <p>Öffentliche Verfügbarkeit im Browser ohne lokale Installation.</p>
            </div>
            <div class="visual-panel">
                <ul class="tech-list">
                    <li>
                        <i class="fab fa-react" style="color: #61DAFB;"></i>
                        <span>React.js</span>
                    </li>
                    <li>
                        <i class="fab fa-sass" style="color: #CC6699;"></i>
                        <span>SCSS</span>
                    </li>
                    <li>
                        <i class="fab fa-npm" style="color: #CB3837;"></i>
                        <span>NPM</span>
                    </li>
                    <li>
                        <i class="fab fa-git-alt" style="color: #F05032;"></i>
                        <span>Git</span>
                    </li>
                    <li>
                        <i class="fab fa-github" style="color: #ffffff;"></i>
                        <span>GitHub Pages</span>
                    </li>
                </ul>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel goms">
                <h1>GOMS-CMN Analyse</h1>
                <strong>Warum GOMS-CMN?</strong>
                <ul>
                    <li>Flexibel und Verständlich</li>
                    <li>Klare Struktur</li>
                    <li>Strukturiert für Komplexe Aufgaben</li>
                    <li>Vergleicht Steuerungsmethoden</li>
                </ul>

                <p>Modellierung der Benutzerinteraktion für die Aufgabe "Labyrinth lösen".</p>

                <h2>Goals & Methods</h2>
                <ul>
                    <li><strong>GOAL:</strong> Solve Maze</li>
                    <li><strong>METHOD 1:</strong> Use Voice Control (Say "Up", "Down")</li>
                    <li><strong>METHOD 2:</strong> Use Keyboard (WASD / Arrows)</li>
                    <li><strong>METHOD 3:</strong> Use Touch Buttons</li>
                </ul>

                <h2>Selection Rules (Beispiel)</h2>
                <p>
                    <em>RULE 1:</em> Select USE-VOICE-CONTROL-METHOD to use voice controls.
                    <em>RULE 2:</em> Select USE-KEYBOARD-KEYS-METHOD to use keyboard keys.<br>
                    <em>RULE 3:</em> Select USE-TOUCH-BUTTONS-METHOD to use touch controls.<br>
                </p>
            </div>
            <div class="visual-panel">
                <div class="code-panel">
                    <div class="code-header">
                        <div class="dot red"></div>
                        <div class="dot yellow"></div>
                        <div class="dot green"></div>
                    </div>
                    <pre><code class="language-javascript">
GOMS-CMN
GOAL: 	Solve a maze
.		[select		GOAL:		USE-VOICE-CONTROL-METHOD
.		.			GOAL:		USE-KEYBOARD-KEYS-METHOD
.		.			GOAL:		USE-TOUCH-BUTTONS]
                
GOAL:		USE-VOICE-CONTROL-METHOD
.		.		.		GOAL: GENERATE-MAZE
.		.		.		                    MOVE-MOUSE-TO-GENERATE-MAZE-BUTTON
.		.		.				  CLICK-LEFT-MOUSE-BUTTON
.		.		.		GOAL: ENABLE-VOICE-CONTROL
.		.		.				MOVE-MOUSE-TO-MICROPHONE-BUTTON
.		.		.				CLICK-LEFT-MOUSE-BUTTON
.		.		.		GOAL: SOLVE-MAZE-USING-VOICE-CONTROL
.		.		.				SAY-VOICE-COMMAND(’UP’/’DOWN’/’RIGHT’/’LEFT’)
.		.		.				REACH-THE-END-USING-VOICE-COMMANDS
                
GOAL:		USE-KEYBOARD-KEYS-METHOD
.		.		.		GOAL: GENERATE-MAZE
.		.		.			MOVE-MOUSE-TO-GENERATE-MAZE-BUTTON
.		.		.			CLICK-LEFT-MOUSE-BUTTON
.		.		.		GOAL: NAVIGATE-MAZE-USING- KEYBOARD-KEYS-
.		.		.			PRESS-KEYBOARD-KEYS(“W”/”S”/”A”/”D”)
.		.		.			REACH-THE-END-USING-KEYBOARD-KEYS
GOAL:		USE-TOUCH-BUTTONS-METHOD
.		.		.		GOAL:GENERATE-MAZE
.		.		.			PRESS-GENERATE-MAZE-BUTTON-WITH-FINGER
.		.		.		GOAL:NAVIGATE-MAZE-USING-TOUCH-SCREEN
.		.		.			PRESS-ARROW-BUTTONS-TO-NAVIGATE-USING-FINGER-ON-SCREEN
.		.		.			REACH-THE-END.
RULE 1: Select USE-VOICE-CONTROL-METHOD to use voice controls
RULE 2: Select USE-KEYBOARD-KEYS-METHOD to use keyboard keys
RULE 3: Select USE-TOUCH-BUTTONS-METHOD to use touch controls
                            </code></pre>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>1. Datenstruktur: Klasse "Cell"</h1>
                <p>Die <code>Cell</code> ist die fundamentale Einheit. Sie ist nicht nur ein grafisches Element, sondern
                    ein <strong>Knoten im Graphen</strong>.</p>

                <h2>Technische Highlights</h2>
                <ul>
                    <li><strong>Topologie:</strong> Das Array <code>walls</code> definiert die Kanten des Graphen.</li>
                    <li><strong>Speicher-Optimierung:</strong> Umrechnung von 2D-Koordinaten in ein <strong>lineares
                            1D-Array</strong> für effizienteren Speicherzugriff (Cache Locality).</li>
                    <li><strong>Vektor-Rendering:</strong> Zeichnung über <code>ctx.moveTo/lineTo</code> statt einfacher
                        Rechtecke für scharfe Darstellung.</li>
                </ul>
            </div>
            <div class="visual-panel">
                <div class="code-panel">
                    <div class="code-header">
                        <div class="dot red"></div>
                        <div class="dot yellow"></div>
                        <div class="dot green"></div>
                    </div>
                    <pre><code class="language-javascript">
function Cell(i, j, size, cols, rows) {
  // 1. Initialisierung: Logische Koordinaten & Physische Position
  this.i = i;
  this.j = j;
  this.x = i * size; // Optimierung: Koordinaten nur einmal berechnen
  this.y = j * size;
  this.cols = cols;
  this.rows = rows;

  // 2. Graph-Topologie
  // walls = [Oben, Rechts, Unten, Links] -> true = Wand, false = Weg
  this.walls = [true, true, true, true];
  
  // 3. Status für Algorithmen (DFS & BFS)
  this.visited = false;
  this.distanceToStart = Infinity;

  // Methode: Rendering auf dem Canvas (Vektorgrafik)
  this.draw = function (ctx) {
    ctx.beginPath(); 
    // Nur aktive Wände werden gezeichnet
    if (this.walls[0]) { ctx.moveTo(x, y); ctx.lineTo(x + size, y); }           
    if (this.walls[1]) { ctx.moveTo(x + size, y); ctx.lineTo(x + size, y + size); } 
    // ... usw.
    ctx.stroke();
  };

  // Methode: Nachbarn finden (für Graph-Traversierung)
  this.checkNeighbors = function (cells) {
    const neighbors = [];

    // Umrechnung von 2D (Grid) zu 1D (Array Speicher)
    const idx = (c, r) => index(c, r, this.cols, this.rows);

    // Zugriff auf potenzielle Nachbarn im 1D-Array
    const top = cells[idx(this.i, this.j - 1)];
    const right = cells[idx(this.i + 1, this.j)];
    // ...
    
    // Validierung: Existiert die Zelle und wurde sie noch nicht besucht?
    if (top && !top.visited) neighbors.push(top);
    // ...
    
    // Rückgabe eines zufälligen Nachbarn (für Random Walk)
    return neighbors[Math.floor(Math.random() * neighbors.length)];
  };
}
                    </code></pre>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>2. Generierung: Iteratives Backtracking</h1>
                <p>Wir verwenden einen <strong>Stack-basierten DFS (Depth First Search)</strong> Algorithmus, bekannt
                    als "Recursive Backtracker".</p>
                <p>Der Algorithmus gräbt sich durch das Raster, bis er stecken bleibt, und kehrt dann über den
                    <code>Stack</code> zurück (Backtracking), um neue Wege zu finden. Dies garantiert ein
                    <strong>perfektes Labyrinth</strong> (genau ein Pfad zwischen zwei Punkten, keine Schleifen).</p>
            </div>
            <div class="visual-panel">
                <div class="code-panel">
                    <div class="code-header">
                        <div class="dot red"></div>
                        <div class="dot yellow"></div>
                        <div class="dot green"></div>
                    </div>
                    <pre><code class="language-javascript">
// Generierungs-Loop (Iteratives Backtracking)
if (localCurrent) {
  // 1. Suche nach einem unbesuchten Nachbarn
  const next = localCurrent.checkNeighbors(localCells);

  if (next) {
    next.visited = true;
    
    // 2. Aktuelle Position auf den Stack pushen (für den Rückweg)
    localStack.push(localCurrent);
    
    // 3. Wand zwischen aktueller und nächster Zelle entfernen
    removeWalls(localCurrent, next);
    
    // 4. Zeiger bewegen
    localCurrent = next;

  } else if (localStack.length > 0) {
    // 5. Sackgasse erreicht! Backtracking via Stack
    localCurrent = localStack.pop();
  }
}
                    </code></pre>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>3. Zielfindung: BFS Algorithmus</h1>
                <p>Um das Spiel herausfordernd zu machen, setzen wir das Ziel nicht zufällig.</p>
                <p>Wir nutzen eine <strong>Breitensuche (BFS)</strong>, um das Labyrinth vom Startpunkt aus zu "fluten".
                    Wir berechnen die Distanz (Kosten) zu jeder Zelle. Die Zelle mit dem maximalen Wert wird der Exit.
                </p>
                <p><em>Technischer Hinweis:</em> Wir nutzen eine <code>Queue</code> (FIFO) statt eines Stacks.</p>
            </div>
            <div class="visual-panel">
                <div class="code-panel">
                    <div class="code-header">
                        <div class="dot red"></div>
                        <div class="dot yellow"></div>
                        <div class="dot green"></div>
                    </div>
                    <pre><code class="language-javascript">
function bfs(startCell, cells) {
  // Queue für Breitensuche (FIFO - First In, First Out)
  const queue = [startCell];
  const localVisited = new Set([startCell]);

  startCell.distanceToStart = 0;

  while (queue.length > 0) {
    // Das älteste Element aus der Schlange nehmen
    const currentCell = queue.shift();

    // Nachbarn iterieren (nur die ohne Wände dazwischen)
    for (let neighbor of findNeighborsBFS(currentCell, cells)) {
      if (!localVisited.has(neighbor)) {
        localVisited.add(neighbor);
        queue.push(neighbor);
        
        // Die Distanz erhöht sich um 1 Schritt (Kostenfunktion)
        neighbor.distanceToStart = currentCell.distanceToStart + 1;
      }
    }
  }
}

function findLongestPath(cells) {
  // Lineare Suche nach dem Maximum (O(n))
  for (let cell of cells) {
    if (cell.distanceToStart > maxDistance) {
      maxDistance = cell.distanceToStart;
      exitCell = cell;
    }
  }
  return exitCell;
}
                    </code></pre>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>4. Player & State Management</h1>
                <p>Die <code>Player</code> Klasse fungiert als kleine <strong>State Machine</strong>.</p>
                <p>Wir entkoppeln die logische Position (Grid-Index) von der visuellen Position (Pixel). Während die
                    Logik sofort aktualisiert wird, nutzt das Rendering eine <strong>lineare Interpolation</strong> für
                    flüssige Bewegungen.</p>
            </div>
            <div class="visual-panel">
                <div class="code-panel">
                    <div class="code-header">
                        <div class="dot red"></div>
                        <div class="dot yellow"></div>
                        <div class="dot green"></div>
                    </div>
                    <pre><code class="language-javascript">
export default class Player {
  constructor(startCell, cellSize) {
    // Initialisierung der Position
    this.setPositionFromCell(startCell);

    // State-Variablen für die Animation
    this.startPos = { x: this.x, y: this.y }; // Wo war ich?
    this.endPos = { x: this.x, y: this.y };   // Wo will ich hin?
    
    // Progress-Flag: 1 = Idle, 0 = Moving
    this.progress = 1; 
  }

  // Wird bei validem Input aufgerufen
  moveTo(targetCell) {
    // 1. Logischen Zustand aktualisieren (Start -> Ziel)
    this.startPos = { x: this.x, y: this.y };
    this.endPos = { 
        x: targetCell.x + this.cellSize / 2, 
        y: targetCell.y + this.cellSize / 2 
    };
    
    // 2. Animation trigger (Reset Zeit)
    this.elapsed = 0;
    this.progress = 0; 
  }
  
  // update(dt) { ... interpoliert zwischen startPos und endPos ... }
}
                    </code></pre>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>5. Web Speech API Integration</h1>
                <p>Verwendung der nativen Browser-Schnittstelle für Barrierefreiheit und Datenschutz (kein Server-Upload
                    nötig).</p>

                <h2>Wichtige Konfigurationen</h2>
                <ul>
                    <li><code>continuous = true</code>: Das Mikrofon bleibt offen und erlaubt Befehlsketten ("Hoch,
                        Links, Hoch").</li>
                    <li><code>interimResults = false</code>: Wir warten auf das finale Ergebnis für höhere Konfidenz und
                        Präzision.</li>
                </ul>
            </div>
            <div class="visual-panel">
                <div class="code-panel">
                    <div class="code-header">
                        <div class="dot red"></div>
                        <div class="dot yellow"></div>
                        <div class="dot green"></div>
                    </div>
                    <pre><code class="language-javascript">
// src/hooks/useVoiceControl.js

useEffect(() => {
    // 1. Verfügbarkeit prüfen (Cross-Browser Support)
    const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SpeechRecognition) {
        console.warn("API not supported");
        return;
    }

    const recognition = new SpeechRecognition();
    recognition.continuous = true; 
    recognition.interimResults = false;

    // 2. Ergebnis-Verarbeitungsschleife
    recognition.onresult = (event) => {
        // Iteration über den Result-Buffer (verhindert Datenverlust)
        for (let i = event.resultIndex; i < event.results.length; ++i) {
            const result = event.results[i];
            
            // Nur finalisierte Ergebnisse verarbeiten
            if (result.isFinal) {
                const transcript = result[0].transcript.trim();
                onResult({ transcript, confidence: result[0].confidence });
            }
        }
    };

    // 3. Fehlerbehandlung & Sicherheit
    recognition.onerror = (event) => {
        if (event.error === 'not-allowed') setIsListening(false);
    };

    // 4. Keep-Alive Logik (Auto-Restart)
    recognition.onend = () => {
        // Wenn wir noch zuhören sollen, starten wir die Engine neu
        if(isListeningRef.current) {
            try { recognition.start(); } catch(e) { /* ignore */ }
        }
    };
}, []);
                    </code></pre>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>6. Natural Language Processing (Regex)</h1>
                <p>Der Benutzer spricht natürlich (z.B. "Geh drei mal nach oben").</p>
                <p>Wir nutzen <strong>Reguläre Ausdrücke (Regex)</strong>, um Quantifizierer (Zahlen) und Aktionen
                    (Richtungen) zu extrahieren und in eine Befehls-Queue umzuwandeln.</p>
            </div>
            <div class="visual-panel">
                <div class="code-panel">
                    <div class="code-header">
                        <div class="dot red"></div>
                        <div class="dot yellow"></div>
                        <div class="dot green"></div>
                    </div>
                    <pre><code class="language-javascript">
// src/utils/voiceCommandsMap.js

// 1. Multilinguale Mustererkennung
// \b = Wortgrenze (Word Boundary), | = ODER
function interpretVoiceCommand(word) {
    const t = word.toLowerCase().trim();
    
    // Erkennt: "arriba", "up", "oben", "hoch"...
    if (/\b(subir|arriba|up|oben|hoch)\b/.test(t)) return "UP";
    
    // Erkennt: "bajar", "down", "unten", "runter"...
    if (/\b(bajar|abajo|down|unten|runter)\b/.test(t)) return "DOWN";
    
    // ... (Logik für Left/Right/Reset)
    return null;
}

export function interpretSequence(transcript) {
    // 2. Normalisierung: Konjunktionen ("und", "y") durch Kommas ersetzen
    const normalized = transcript.replace(/\s+(y|und|and)\s+/g, ",");
    
    // String in einzelne Befehlssegmente splitten
    const parts = normalized.split(/[,;]+/).map(s => s.trim());
    const out = [];

    for (const part of parts) {
        // 3. Extraktion von Quantifizierern (Zahlen oder Wörter)
        const numMatch = part.match(/\b(\d+|uno|two|drei...)\b/);
        let repeat = numMatch ? parseNumberToken(numMatch[1]) : 1;

        // Befehle vervielfachen (Command Pattern)
        const cmd = interpretVoiceCommand(part);
        if (cmd) {
            for (let r = 0; r < repeat; r++) out.push(cmd);
        }
    }
    return out;
}
                    </code></pre>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>7. Performance: Double Buffering</h1>
                <p>Da das Labyrinth aus hunderten Linien besteht, wäre ein Neuzeichnen in jedem Frame (60 FPS) zu teuer.
                </p>
                <p><strong>Lösung: OffscreenCanvas.</strong> Wir zeichnen das statische Labyrinth einmalig in den
                    Speicher und kopieren es dann als Bild (Bit-Blit) in jedem Frame. Nur der Spieler wird neu
                    berechnet.</p>
            </div>
            <div class="visual-panel">
                <div class="code-panel">
                    <div class="code-header">
                        <div class="dot red"></div>
                        <div class="dot yellow"></div>
                        <div class="dot green"></div>
                    </div>
                    <pre><code class="language-javascript">
// 1. Rendering des statischen Labyrinths in den Speicher (Memoized)
const drawMazeToOffscreen = useCallback((cells) => {
  if (!offscreenCanvasRef.current) return;
  const offCtx = offscreenCanvasRef.current.getContext("2d");
  
  // Teure Operation: Hunderte von Wänden zeichnen
  // Passiert nur 1x bei Generierung oder Resize!
  for (const cell of cells) {
      cell.draw(offCtx);
  }
}, []);

// 2. Render-Loop (60 FPS)
const redrawAll = useCallback(() => {
  const ctx = ctxRef.current;
  
  // Canvas leeren
  ctx.clearRect(0, 0, width, height);
  
  // Kopieren des statischen Bildes aus dem Speicher (Sehr schnell)
  if (offscreenCanvasRef.current) {
    ctx.drawImage(offscreenCanvasRef.current, 0, 0);
  }
}, []);
                    </code></pre>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>Geplante Evaluierung & User Testing</h1>
                <p>Wir planen eine quantitative Umfrage, um das System zu validieren.</p>

                <h2>Struktur der Umfrage</h2>
                <p><strong>30 Fragen</strong> in 4 Hauptkategorien (Skala 1-5):</p>
                <ol>
                    <li><strong>Design & Visuelles Feedback:</strong> Übersichtlichkeit, Icons, Kontrast.</li>
                    <li><strong>Bedienbarkeit & Technik:</strong> Stabilität, Menüführung, Performance.</li>
                    <li><strong>Sprachsteuerung:</strong> Erkennungsrate, Intuitivität der Befehle.</li>
                    <li><strong>Gesamteindruck:</strong> Spielspaß und Lernkurve.</li>
                </ol>

                <p style="margin-top:20px; color:var(--accent);">Nehmen Sie an der Umfrage teil:</p>
                <a href="https://forms.gle/rvwf2fAKFqTZm2nk6" class="btn-primary">
                    <i class="fas fa-poll-h"></i> Zur Umfrage
                </a>
            </div>
            <div class="visual-panel">
                <div class="qr-panel">
                    <img src="https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=https://forms.gle/rvwf2fAKFqTZm2nk6"
                        class="qr-img" alt="Umfrage QR">
                    <p class="qr-caption">Zur Umfrage</p>
                </div>
            </div>
        </div>

        <div class="slide split-content">
            <div class="content-panel">
                <h1>Vielen Dank!</h1>
                <p>Das Projekt ist live verfügbar.</p>
                <p>Testen Sie Ihre Fähigkeiten und die Sprachsteuerung direkt im Browser.</p>

                <a href="https://lenis-jf.github.io/voice-controlled-maze/" target="_blank" class="btn-primary">
                    <i class="fas fa-play"></i> Jetzt Spielen
                </a>

                <a href="https://github.com/Lenis-jf/voice-controlled-maze" target="_blank" class="btn-secondary">
                    <i class="fab fa-github"></i> Github Repository
                </a>
            </div>
            <div class="visual-panel">
                <div class="qr-panel">
                    <img src="https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=https://lenis-jf.github.io/voice-controlled-maze/"
                        class="qr-img" alt="Spiel QR Code">
                    <p class="qr-caption play-caption">Scannen zum Spielen</p>
                </div>
            </div>
        </div>

        <div class="slide-counter">Folie <span id="current">1</span> / <span id="total">14</span></div>

    </div>

    <div class="controls">
        <button class="nav-btn" onclick="prevSlide()">← Zurück</button>
        <button class="nav-btn" onclick="nextSlide()">Weiter →</button>
    </div>

    <div class="menu-toggle" id="menuToggle">
        <i class="fas fa-th-large"></i>
    </div>

    <div class="slide-nav-menu" id="slideNavMenu">
        <div class="menu-header">
            <h3>Slides Preview</h3>
            <button class="close-menu" id="closeMenu"><i class="fas fa-times"></i></button>
        </div>
        <div class="menu-items-container" id="menuItemsContainer">
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="script.js?v=3.0"></script>

</body>

</html>