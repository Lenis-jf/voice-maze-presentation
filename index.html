<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Controlled Maze - Präsentation</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Fira+Code:wght@400;500&display=swap"
        rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />

    <style>
        :root {
            --bg-color: #0a0f1d;
            --accent: #00e1ff;
            --text: #e2e8f0;
            --text-muted: #94a3b8;
            --glass-bg: rgba(20, 25, 40, 0.75);
            --glass-border: rgba(255, 255, 255, 0.08);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: var(--bg-color);
            background-image:
                radial-gradient(circle at 10% 20%, rgba(0, 225, 255, 0.1) 0%, transparent 40%),
                radial-gradient(circle at 90% 80%, rgba(139, 92, 246, 0.1) 0%, transparent 40%);
            color: var(--text);
            font-family: 'Inter', sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            perspective: 1000px;
        }

        .presentation-container {
            width: 92%;
            max-width: 1400px;
            height: 88vh;
            position: relative;
        }

        /* --- SLIDES --- */
        .slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: 1fr 1.4fr;
            gap: 3rem;
            padding: 2.5rem;
            background: var(--glass-bg);
            border-radius: 24px;
            box-shadow:
                0 20px 50px -10px rgba(0, 0, 0, 0.5),
                inset 0 0 20px rgba(255, 255, 255, 0.02);
            backdrop-filter: blur(16px) saturate(120%);
            border: 1px solid var(--glass-border);
            /* Estado oculto por defecto */
            opacity: 0;
            visibility: hidden;
            transform: translateY(40px) scale(0.96) rotateX(4deg);
            pointer-events: none;
            transition: all 0.7s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        .slide.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0) scale(1) rotateX(0deg);
            z-index: 10;
            pointer-events: auto;
            transition-delay: 0.1s;
        }

        /* --- CONTENT & PANELS --- */
        .content-panel {
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        h1 {
            font-size: 2.4rem;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 1.5rem;
            line-height: 1.1;
            letter-spacing: -0.5px;
            text-shadow: 0 0 15px rgba(0, 225, 255, 0.4);
        }

        p {
            font-size: 1.1rem;
            line-height: 1.7;
            color: var(--text-muted);
            margin-bottom: 1.2rem;
        }

        strong {
            color: var(--text);
            font-weight: 600;
        }

        /* Code Panel Styles */
        .code-panel {
            background: #121212;
            border-radius: 16px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.6), 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid #2a2a2a;
            transform: translateZ(0);
        }

        .code-header {
            background: #1a1a1a;
            padding: 12px 18px;
            display: flex;
            gap: 8px;
            border-bottom: 1px solid #2a2a2a;
            align-items: center;
        }

        .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            transition: filter 0.2s;
        }

        .red {
            background: #ff5f56;
        }

        .yellow {
            background: #ffbd2e;
        }

        .green {
            background: #27c93f;
        }

        .code-panel:hover .dot {
            filter: brightness(1.2);
        }

        pre {
            margin: 0 !important;
            height: 100%;
            overflow-y: auto !important;
            padding: 1.5rem !important;
            font-family: 'Fira Code', monospace !important;
            font-size: 0.95rem;
            line-height: 1.5 !important;
        }

        /* QR Panel Styles */
        .qr-panel {
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(255, 255, 255, 0.03);
            border-radius: 16px;
            border: 1px solid var(--glass-border);
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.6);
            flex-direction: column;
            gap: 20px;
        }

        .qr-img {
            border-radius: 12px;
            border: 8px solid white;
            /* Borde blanco para facilitar escaneo */
            width: 280px;
            height: 280px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.5);
            transition: transform 0.3s ease;
        }

        .qr-img:hover {
            transform: scale(1.05);
        }

        .qr-caption {
            font-family: 'Fira Code', monospace;
            color: var(--accent);
            font-size: 0.9rem;
        }

        /* Scrollbar */
        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #334155;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        /* --- CONTROLS --- */
        .controls {
            position: absolute;
            bottom: 30px;
            right: 40px;
            display: flex;
            gap: 20px;
            z-index: 20;
        }

        button {
            position: relative;
            background: transparent;
            border: 2px solid var(--accent);
            padding: 12px 28px;
            border-radius: 12px;
            color: var(--accent);
            font-weight: 600;
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            cursor: pointer;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            backdrop-filter: blur(5px);
        }

        button::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(to bottom right,
                    rgba(255, 255, 255, 0) 0%,
                    rgba(255, 255, 255, 0.2) 50%,
                    rgba(255, 255, 255, 0) 100%);
            transform: rotate(45deg) translateY(-100%);
            transition: transform 0.4s ease-out;
            pointer-events: none;
        }

        button:hover {
            background: var(--accent);
            color: var(--bg-color);
            transform: translateY(-4px) scale(1.05);
            box-shadow: 0 15px 30px -5px rgba(0, 225, 255, 0.5), 0 0 15px var(--accent);
        }

        button:hover::after {
            transform: rotate(45deg) translateY(100%);
        }

        button:active {
            transform: translateY(-1px) scale(0.98);
            box-shadow: 0 5px 15px -5px rgba(0, 225, 255, 0.5);
        }

        /* --- SLIDE COUNTER --- */
        .slide-counter {
            position: absolute;
            bottom: 45px;
            left: 50px;
            z-index: 30;
            font-family: 'Fira Code', monospace;
            color: var(--accent);
            font-size: 1rem;
            letter-spacing: 1px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid rgba(0, 225, 255, 0.2);
            opacity: 0;
            transform: translateY(10px);
            pointer-events: none;
            transition: opacity 0.2s ease-in, transform 0.2s ease-in;
        }

        .slide-counter.visible {
            opacity: 1;
            transform: translateY(0);
            transition: opacity 0.5s ease-out, transform 0.5s ease-out;
        }

        /* --- RESPONSIVE FIX (Mobile) --- */
        @media (max-width: 900px) {
            .slide {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
                gap: 1.5rem;
                padding: 1.5rem;
                overflow-y: auto;
            }

            h1 {
                font-size: 1.8rem;
            }

            .code-panel,
            .qr-panel {
                min-height: 350px;
                margin-bottom: 80px;
            }

            .qr-img {
                width: 200px;
                height: 200px;
            }

            .controls {
                bottom: 15px;
                right: 20px;
                width: auto;
            }

            button {
                padding: 10px 20px;
                font-size: 0.9rem;
            }

            .slide-counter {
                bottom: 20px;
                left: 20px;
                font-size: 0.8rem;
            }
        }
    </style>
</head>

<body>

    <div class="presentation-container">

        <div class="slide active">
            <div class="content-panel">
                <h1>Voice Controlled Maze</h1>
                <p><strong>Technische Präsentation</strong></p>
                <p>Willkommen. Dies ist eine exemplarische Darstellung der entscheidenden Codeblöcke des Projekts.</p>
                <p style="color: var(--accent);">Scannen Sie den QR-Code, um diese Präsentation auf Ihrem Smartphone zu
                    visualisieren.</p>
            </div>
            <div class="qr-panel">
                <img src="https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=https://lenis-jf.github.io/voice-maze-presentation/"
                    class="qr-img" alt="Präsentation QR Code">
                <span class="qr-caption">Scan to view Slides</span>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>2. BFS-Algorithmus zum Finden des Ausgangs</h1>
                <p><strong>Strategie "Farthest Cell":</strong> Implementierung einer Breitensuche (BFS), um das gesamte
                    Labyrinth vom Startpunkt aus zu durchqueren.</p>
                <p>Wir berechnen die Distanz zu jeder Zelle und wählen die am weitesten entfernte als "Ausgang" (Exit).
                </p>
            </div>
            <div class="code-panel">
                <div class="code-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
                <pre><code class="language-javascript">
// src/components/Maze.jsx

function bfs(startCell, cells) {
  for (let cell of cells) {
    cell.distanceToStart = Infinity;
    cell.isExit = false;
  }
  const queue = [startCell];
  const localVisited = new Set([startCell]);
  startCell.distanceToStart = 0;

  while (queue.length > 0) {
    const currentCell = queue.shift();
    // findNeighborsBFS gibt erreichbare Nachbarn zurück 
    for (let neighbor of findNeighborsBFS(currentCell, cells)) {
      if (!localVisited.has(neighbor)) {
        localVisited.add(neighbor);
        queue.push(neighbor);
        neighbor.distanceToStart = currentCell.distanceToStart + 1;
      }
    }
  }
}
                </code></pre>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>3. Backtracking-Algorithmus (Generierung)</h1>
                <p><strong>Das Herzstück der Labyrinth-Erstellung.</strong></p>
                <p>Es wird eine iterative Backtracking-Technik mit einem Stack verwendet. Der Algorithmus besucht eine
                    Zelle, durchbricht Wände zu zufälligen Nachbarn und rückt vor. Wenn er keine Optionen mehr hat, geht
                    er zurück (Stack Pop), bis ein neuer Weg gefunden wird.</p>
            </div>
            <div class="code-panel">
                <div class="code-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
                <pre><code class="language-javascript">
// src/components/Maze.jsx (innerhalb der Animationsschleife)

// DFS-Algorithmus (Backtracking)
if (localCurrent) {
  const next = localCurrent.checkNeighbors(localCells);
  if (next) {
    next.visited = true;
    
    // Zum Stack hinzufügen, um "zurückkehren" zu können
    localStack.push(localCurrent);
    
    // Wände zwischen aktueller und nächster Zelle einreißen
    removeWalls(localCurrent, next);
    
    // Zeiger bewegen
    localCurrent = next;
  } else if (localStack.length > 0) {
    // Wenn keine Nachbarn vorhanden, zurückgehen (Backtracking)
    localCurrent = localStack.pop();
  }
}
                </code></pre>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>4. Spielerlogik (Klasse Player)</h1>
                <p>Die Klasse <code>Player</code> kapselt die Physik und die interpolierte Bewegung.</p>
                <p>Hervorzuheben ist die Methode <code>update</code>, die eine Easing-Funktion
                    (<strong>easeOutSine</strong>) verwendet, um die Bewegung zwischen den Zellen zu glätten.</p>
            </div>
            <div class="code-panel">
                <div class="code-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
                <pre><code class="language-javascript">
// src/components/Player.js

export default class Player {
  constructor(startCell, cellSize, options = {}) {
    this.cellSize = cellSize;
    this.setPositionFromCell(startCell);
  }

  // update wird in jedem Frame der Spielschleife aufgerufen
  update(dt) {
    // Weiche Bewegung zwischen startPos und endPos
    if (this.progress < 1) {
      this.elapsed += dt;
      const t = Math.min(1, this.elapsed / this.moveDuration);
      const eased = easeOutSine(t);
      
      // Lineare Interpolation
      this.x = lerp(this.startPos.x, this.endPos.x, eased);
      this.y = lerp(this.startPos.y, this.endPos.y, eased);
      this.progress = t;
    }

    if (this.bouncing) {
      // ... Berechnungen zur Simulation des visuellen Aufpralls
    }
  }
}
                </code></pre>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>5. Klasse Zelle (Cell)</h1>
                <p>Die fundamentale Einheit des Rasters.</p>
                <p>Sie verwaltet ihre Position, ihren Zustand (besucht, Start, Ende) und ihre <strong>4 Wände</strong>.
                    Sie enthält die Logik <code>checkNeighbors</code> für die zufällige Generierung und ihre eigene
                    Zeichenmethode für das Canvas.</p>
            </div>
            <div class="code-panel">
                <div class="code-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
                <pre><code class="language-javascript">
// src/components/Maze.jsx

function Cell(i, j, size, cols, rows) {
  this.i = i;
  this.j = j;
  this.walls = [true, true, true, true]; // [Oben, Rechts, Unten, Links]
  this.visited = false;
  
  // Methode zur Suche nach nicht besuchten Nachbarn
  this.checkNeighbors = function (cells) {
    const neighbors = [];
    // ... Logik zum Abrufen von Nachbarindizes
    
    // Gibt einen zufälligen Nachbarn zurück, falls vorhanden
    if (neighbors.length > 0) {
      return neighbors[Math.floor(Math.random() * neighbors.length)];
    }
    return undefined;
  };

  this.draw = function (ctx) {
    // Zeichnet nur die Wände, die 'true' sind
    if (this.walls[0]) { ctx.moveTo(x, y); ctx.lineTo(x + size, y); }
    if (this.walls[1]) { ctx.moveTo(x + size, y); ctx.lineTo(x + size, y + size); }
    // ... usw.
  };
}
                </code></pre>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>6. Optimierung (Offscreen Canvas)</h1>
                <p>Zur Vermeidung von Leistungsproblemen (niedrige FPS).</p>
                <p>Implementierung von <strong>Double Buffer</strong>. Das statische Labyrinth wird nur EINMAL in den
                    Speicher gezeichnet. In jedem Frame "kopieren" wir dieses Bild und zeichnen den Spieler darüber.</p>
            </div>
            <div class="code-panel">
                <div class="code-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
                <pre><code class="language-javascript">
// src/components/Maze.jsx

const drawMazeToOffscreen = useCallback((cols, rows, cellsArray) => {
  // ... Konfiguration des Offscreen-Canvas
  
  // Wir zeichnen alle Zellen HIER nur EINMAL
  for (const cell of cellsArray) {
      cell.draw(offCtx);
  }
}, []);

const redrawAll = useCallback(() => {
  const ctx = ctxRef.current; // Sichtbares Canvas
  ctx.clearRect(0, 0, width, height);
  
  // Kopieren des statischen Labyrinthbildes sofort
  if (offscreenCanvasRef.current) {
    ctx.drawImage(offscreenCanvasRef.current, 0, 0, width, height);
  }
}, []);
                </code></pre>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>7. Sprachsteuerung (WebSpeech API)</h1>
                <p>Native Browser-Integration für Barrierefreiheit und modernes Gameplay.</p>
                <p>Wir konfigurieren die kontinuierliche Erkennung und erfassen das <code>transcript</code> in Echtzeit,
                    um es an den Befehlsprozessor zu senden.</p>
            </div>
            <div class="code-panel">
                <div class="code-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
                <pre><code class="language-javascript">
// src/hooks/useVoiceControl.js

// Grundlegende Konfiguration der Erkennung
const recognition = new SpeechRecognition();
recognition.lang = lang;
recognition.continuous = true;
recognition.interimResults = false;

recognition.onresult = (event) => {
    const lastResult = event.results[event.results.length - 1];
    const transcript = lastResult[0].transcript;
    // Callback an die Hauptkomponente mit dem gehörten Text
    onResult({ transcript, confidence: lastResult[0].confidence });
};
                </code></pre>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>8. Interpretation mit Regex</h1>
                <p>Analyse natürlicher Sprache für komplexe Befehle.</p>
                <p>Wir verwenden <strong>Reguläre Ausdrücke</strong>, um Mengen ("zwei", "3") und Richtungen zu
                    extrahieren. Dies ermöglicht es dem Benutzer, "Dreimal hoch" zu sagen.</p>
            </div>
            <div class="code-panel">
                <div class="code-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
                <pre><code class="language-javascript">
// src/utils/voiceCommandsMap.js

export function interpretSequence(transcript = "") {
    // Erkennen von Zahlen gefolgt von einem Befehl
    const numMatch = part.match(/\b(\d+|uno|dos|three|four...)\b/);
    
    // Wenn eine Zahl vorhanden ist, Wiederholungen festlegen
    if (numMatch) repeat = parseNumberToken(numMatch[1]) || 1;

    // Suche nach Richtungs-Schlüsselwörtern
    for (const w of words) {
        const cmd = interpretVoiceCommand(w); // Gibt "UP", "DOWN" zurück
        if (cmd) found.push(cmd);
    }
    
    // Multiplizieren der gefundenen Befehle
    for (let r = 0; r < repeat; r++) {
        out.push(...found);
    }
    return out;
}
                </code></pre>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>Vielen Dank!</h1>
                <p>Das Projekt ist live und spielbar.</p>
                <p>Testen Sie Ihre Fähigkeiten und die Sprachsteuerung direkt im Browser.</p>
                <p style="color: var(--accent);"><strong>Scannen Sie den QR-Code, um zum Spiel zu gelangen.</strong></p>
            </div>
            <div class="qr-panel">
                <img src="https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=https://lenis-jf.github.io/voice-controlled-maze/"
                    class="qr-img" alt="Maze Game QR Code">
                <span class="qr-caption">Scan to Play</span>
            </div>
        </div>

        <div class="slide-counter">Folie <span id="current">1</span> / <span id="total">9</span></div>

        <div class="controls">
            <button onclick="prevSlide()">← Zurück</button>
            <button onclick="nextSlide()">Weiter →</button>
        </div>
    </div>

    <script>
        let currentSlide = 0;
        const slides = document.querySelectorAll('.slide');
        const counterCurrent = document.getElementById('current');
        const counterTotal = document.getElementById('total');
        const counterEl = document.querySelector('.slide-counter');

        // Inicializar contador total automáticamente
        counterTotal.innerText = slides.length;

        // Variable para guardar el temporizador
        let hideTimer;

        function showCounter() {
            // 1. Mostrar inmediatamente añadiendo la clase
            counterEl.classList.add('visible');

            // 2. Limpiar cualquier temporizador anterior (para que no se oculte si diste click rápido)
            if (hideTimer) clearTimeout(hideTimer);

            // 3. Crear un nuevo temporizador de 3 segundos
            hideTimer = setTimeout(() => {
                // Pasados 3 segundos, quitamos la clase y el CSS se encarga del Fade Out
                counterEl.classList.remove('visible');
            }, 3000);
        }

        function showSlide(index) {
            slides.forEach((slide, i) => {
                slide.classList.toggle('active', i === index);
            });
            counterCurrent.innerText = index + 1;

            // Disparar la lógica del contador
            showCounter();
        }

        function nextSlide() {
            if (currentSlide < slides.length - 1) {
                currentSlide++;
                showSlide(currentSlide);
            }
        }

        function prevSlide() {
            if (currentSlide > 0) {
                currentSlide--;
                showSlide(currentSlide);
            }
        }

        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' || e.key === ' ') nextSlide();
            if (e.key === 'ArrowLeft') prevSlide();
        });

        // Mostrar al cargar por primera vez
        showCounter();

    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>

</body>

</html>