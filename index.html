<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Controlled Maze - HMI Präsentation</title>

    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=Fira+Code:wght@400;500&display=swap"
        rel="stylesheet">

    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

    <link rel="stylesheet" href="styles.css?v=2.0">
</head>

<body>

    <div class="presentation-container">

        <div class="slide active split-content">
            <div class="content-panel">
                <h1>Voice Controlled Maze</h1>
                <p>Human Machine Interaction (HMI) Projekt</p>
                <p>Eine moderne Webanwendung, die Sprachsteuerung mit klassischen Labyrinth-Algorithmen verbindet.</p>

                <div class="authors">
                    <p><strong>Entwickelt von:</strong><br>
                        Juan Fernando Lenis Serna<br>
                        Ayman Lahseb</p>
                </div>
            </div>
            <div class="visual-panel">
                <div class="qr-panel">
                    <img src="https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=https://lenis-jf.github.io/voice-maze-presentation/"
                        class="qr-img" alt="Präsentation QR">
                    <p class="qr-caption">Scannen für Slides</p>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>Projektziele & Umfang</h1>
                <h2>Das Hauptziel</h2>
                <p>Entwicklung einer <strong>barrierefreien, modernen und responsiven</strong> Webanwendung für
                    jedermann.</p>

                <h2>Kernfunktionen</h2>
                <ul>
                    <li><strong>Zufällige Generierung:</strong> Jedes Spiel ist einzigartig (Algorithmus-basiert).</li>
                    <li><strong>Anpassbar:</strong> Benutzerdefiniertes Raster (Grid-Size).</li>
                    <li><strong>Visuelles Feedback:</strong> Konstante Rückmeldung über den Spielstatus.</li>
                    <li><strong>Engagement:</strong> Fördert kontinuierliche Verbesserung des Spielers.</li>
                </ul>

                <h2>Steuerung & Accessibility</h2>
                <p>Unterstützt multimodale Eingaben (Tastatur & Stimme). Auf Mobilgeräten kommen <strong>Floating
                        Buttons</strong> zum Einsatz, um die Bewegung des Charakters präzise zu steuern.</p>
            </div>
            <div class="visual-panel">
                <div class="qr-panel no-border">
                    <i class="fas fa-universal-access icon-large"></i>
                    <p style="margin-top:20px; text-align:center;">Unterstützung der Barrierefreiheit durch universelle
                        Eingabemethoden.</p>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>Warum ist das ein gutes HMI-Projekt?</h1>

                <p><strong>Natürliche Interaktion (NUI):</strong><br>
                    Ermöglicht durch Sprachsteuerung. Die Schnittstelle passt sich dem Menschen an, nicht umgekehrt.</p>

                <p><strong>Software-Ergonomie:</strong><br>
                    Das System ist leicht erlernbar und intuitiv zu bedienen. Es erfordert keine komplexe Einarbeitung.
                </p>

                <p><strong>System-Feedback & Status:</strong><br>
                    Auch wenn die Sprachverarbeitung Zeit benötigt, gibt das System visuelles Feedback (z.B.
                    "Listening..."), um die Latenz für den Nutzer transparent zu machen.</p>

                <p><strong>Multimodale Eingabe:</strong><br>
                    Kombination aus diskreten (Tastatur/Touch) und kontinuierlichen (Sprache) Eingabemethoden.</p>
            </div>
            <div class="visual-panel">
                <div class="screenshot-panel">
                    <img src="assets/game-screenshot.png" alt="Game Screenshot" class="screenshot-img">
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>Implementierte Technologien</h1>

                <h2>Frontend: React.js</h2>
                <p>Da die Webanwendung stark von konstantem I/O und schnellen Status-Updates abhängt, haben wir uns für
                    <strong>React.js</strong> entschieden.
                </p>

                <h2>Styling: SCSS</h2>
                <p>Für das Design nutzen wir <strong>SCSS</strong> für ein modulares und strukturiertes Styling.</p>

                <h2>Paket Manager: NPM</h2>
                <p><strong>NPM</strong> ermöglicht die einfache Integration externer Bibliotheken und Tools.</p>

                <h2>Versionierung: Git</h2>
                <p><strong>Git</strong> sorgt für Versionskontrolle und Nachverfolgbarkeit für Teamarbeit.</p>

                <h2>Hosting: GitHub Pages</h2>
                <p>Öffentliche Verfügbarkeit im Browser ohne lokale Installation.</p>
            </div>
            <div class="visual-panel">
                <ul class="tech-list">
                    <li>
                        <i class="fab fa-react" style="color: #61DAFB;"></i>
                        <span>React.js</span>
                    </li>
                    <li>
                        <i class="fab fa-sass" style="color: #CC6699;"></i>
                        <span>SCSS</span>
                    </li>
                    <li>
                        <i class="fab fa-npm" style="color: #CB3837;"></i>
                        <span>NPM</span>
                    </li>
                    <li>
                        <i class="fab fa-git-alt" style="color: #F05032;"></i>
                        <span>Git</span>
                    </li>
                    <li>
                        <i class="fab fa-github" style="color: #ffffff;"></i>
                        <span>GitHub Pages</span>
                    </li>
                </ul>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>GOMS-CMN Analyse</h1>
                <p>Modellierung der Benutzerinteraktion für die Aufgabe "Labyrinth lösen".</p>

                <h2>Goals & Methods</h2>
                <ul>
                    <li><strong>GOAL:</strong> Solve Maze</li>
                    <li><strong>METHOD 1:</strong> Use Voice Control (Say "Up", "Down")</li>
                    <li><strong>METHOD 2:</strong> Use Keyboard (WASD / Arrows)</li>
                    <li><strong>METHOD 3:</strong> Use Touch Buttons</li>
                </ul>

                <h2>Selection Rules (Beispiel)</h2>
                <p><em>RULE 1:</em> Select USE-KEYBOARD if no microphone is available.<br>
                    <em>RULE 2:</em> Select USE-TOUCH if mobile device is detected.
                </p>
            </div>
            <div class="visual-panel">
                <div class="code-panel">
                    <div class="code-header">
                        <div class="dot red"></div>
                        <div class="dot yellow"></div>
                        <div class="dot green"></div>
                    </div>
                    <pre><code class="language-javascript">
GOMS-CMN
GOAL: 	Solve a maze
.		[select		GOAL:		USE-VOICE-CONTROL-METHOD
.		.			GOAL:		USE-KEYBOARD-KEYS-METHOD
.		.			GOAL:		USE-TOUCH-BUTTONS]
                
GOAL:		USE-VOICE-CONTROL-METHOD
.		.		.		GOAL: GENERATE-MAZE
.		.		.		                    MOVE-MOUSE-TO-GENERATE-MAZE-BUTTON
.		.		.				  CLICK-LEFT-MOUSE-BUTTON
.		.		.		GOAL: ENABLE-VOICE-CONTROL
.		.		.				MOVE-MOUSE-TO-MICROPHONE-BUTTON
.		.		.				CLICK-LEFT-MOUSE-BUTTON
.		.		.		GOAL: SOLVE-MAZE-USING-VOICE-CONTROL
.		.		.				SAY-VOICE-COMMAND(’UP’/’DOWN’/’RIGHT’/’LEFT’)
.		.		.				REACH-THE-END-USING-VOICE-COMMANDS
                
GOAL:		USE-KEYBOARD-KEYS-METHOD
.		.		.		GOAL: GENERATE-MAZE
.		.		.			MOVE-MOUSE-TO-GENERATE-MAZE-BUTTON
.		.		.			CLICK-LEFT-MOUSE-BUTTON
.		.		.		GOAL: NAVIGATE-MAZE-USING- KEYBOARD-KEYS-
.		.		.			PRESS-KEYBOARD-KEYS(“W”/”S”/”A”/”D”)
.		.		.			REACH-THE-END-USING-KEYBOARD-KEYS
GOAL:		USE-TOUCH-BUTTONS-METHOD
.		.		.		GOAL:GENERATE-MAZE
.		.		.			PRESS-GENERATE-MAZE-BUTTON-WITH-FINGER
.		.		.		GOAL:NAVIGATE-MAZE-USING-TOUCH-SCREEN
.		.		.			PRESS-ARROW-BUTTONS-TO-NAVIGATE-USING-FINGER-ON-SCREEN
.		.		.			REACH-THE-END.
RULE 1: Select USE-KEYBOARD-KEYS-METHOD if no microphone is available
RULE 2: Select USE-TOUCH-BUTTONS-METHOD if no keyboard is available
                            </code></pre>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>1. Algorithmus: BFS (Farthest Cell)</h1>
                <p>Wir nutzen eine <strong>Breitensuche (BFS)</strong>, um das gesamte Labyrinth vom Startpunkt aus zu
                    durchqueren.</p>
                <p>Dabei wird die Distanz zu jeder Zelle berechnet. Die Zelle mit der maximalen Distanz wird automatisch
                    als "Exit" (Ziel) definiert. Dies garantiert, dass das Ziel immer an einer herausfordernden Position
                    liegt.</p>
            </div>
            <div class="visual-panel">
                <div class="code-panel">
                    <div class="code-header">
                        <div class="dot red"></div>
                        <div class="dot yellow"></div>
                        <div class="dot green"></div>
                    </div>
                    <pre><code class="language-javascript">
// src/components/Maze.jsx

function bfs(startCell, cells) {
  // Distanzen zurücksetzen
  for (let cell of cells) {
    cell.distanceToStart = Infinity;
    cell.isExit = false;
  }
  const queue = [startCell];
  const localVisited = new Set([startCell]);
  startCell.distanceToStart = 0;

  while (queue.length > 0) {
    const currentCell = queue.shift();
    // findNeighborsBFS gibt erreichbare Nachbarn zurück 
    // (ohne Wände dazwischen)
    for (let neighbor of findNeighborsBFS(currentCell, cells)) {
      if (!localVisited.has(neighbor)) {
        localVisited.add(neighbor);
        queue.push(neighbor);
        neighbor.distanceToStart = currentCell.distanceToStart + 1;
      }
    }
  }
}

function findLongestPath(cells) {
  let maxDistance = -1;
  let exitCell = null;
  for (let cell of cells) {
    if (cell.distanceToStart !== Infinity && 
        cell.distanceToStart > maxDistance) {
      maxDistance = cell.distanceToStart;
      exitCell = cell;
    }
  }
  return exitCell;
}
                    </code></pre>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>2. Generierung: Backtracking</h1>
                <p>Das Herzstück der Labyrinth-Erstellung. Wir verwenden <strong>Iteratives Backtracking</strong> mit
                    einem Stack.</p>
                <p>Der Algorithmus besucht eine Zelle, wählt einen zufälligen Nachbarn, durchbricht die Wand und rückt
                    vor. Wenn es keine Nachbarn gibt, geht er zurück (Stack Pop), bis ein neuer Weg gefunden wird.</p>
            </div>
            <div class="visual-panel">
                <div class="code-panel">
                    <div class="code-header">
                        <div class="dot red"></div>
                        <div class="dot yellow"></div>
                        <div class="dot green"></div>
                    </div>
                    <pre><code class="language-javascript">
// src/components/Maze.jsx (innerhalb der Animationsschleife)

// DFS-Algorithmus (Backtracking)
if (localCurrent) {
  const next = localCurrent.checkNeighbors(localCells);
  if (next) {
    next.visited = true;
    
    // Zum Stack hinzufügen für Rückweg
    localStack.push(localCurrent);
    
    // Wände zwischen Zellen entfernen
    removeWalls(localCurrent, next);
    
    // Zeiger bewegen
    localCurrent = next;
  } else if (localStack.length > 0) {
    // Wenn keine Nachbarn, Backtracking
    localCurrent = localStack.pop();
  }
}
                    </code></pre>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>3. Spielerlogik (Klasse Player)</h1>
                <p>Die Klasse <code>Player</code> kapselt die Physik und die interpolierte Bewegung.</p>
                <p>Hervorzuheben ist die Methode <code>update</code>, die <strong>easeOutSine</strong> für weiche
                    Bewegungen nutzt, sowie eine "Bounce"-Logik für visuelles Feedback bei Kollisionen.</p>
            </div>
            <div class="visual-panel">
                <div class="code-panel">
                    <div class="code-header">
                        <div class="dot red"></div>
                        <div class="dot yellow"></div>
                        <div class="dot green"></div>
                    </div>
                    <pre><code class="language-javascript">
// src/components/Player.js

export default class Player {
  constructor(startCell, cellSize, options = {}) {
    this.cellSize = cellSize;
    this.setPositionFromCell(startCell);
    // ... Initialisierung von Zustandsvariablen
  }

  // update wird jeden Frame aufgerufen
  update(dt) {
    // Weiche Bewegung zwischen Positionen
    if (this.progress < 1) {
      this.elapsed += dt;
      const t = Math.min(1, this.elapsed / this.moveDuration);
      const eased = easeOutSine(t);
      
      // Lineare Interpolation
      this.x = lerp(this.startPos.x, this.endPos.x, eased);
      this.y = lerp(this.startPos.y, this.endPos.y, eased);
      this.progress = t;
    }

    // Unabhängige Logik für Kollisionen
    if (this.bouncing) {
      // ... Berechnungen für visuellen Aufprall
    }
  }
  
  // ... Methoden moveTo, draw, etc.
}
                    </code></pre>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>4. Klasse Zelle (Cell)</h1>
                <p>Die fundamentale Einheit des Rasters.</p>
                <p>Sie verwaltet Position, Zustand (visited, start, exit) und die <strong>4 Wände</strong>. Enthält auch
                    die <code>checkNeighbors</code> Logik für die Zufallsgenerierung.</p>
            </div>
            <div class="visual-panel">
                <div class="code-panel">
                    <div class="code-header">
                        <div class="dot red"></div>
                        <div class="dot yellow"></div>
                        <div class="dot green"></div>
                    </div>
                    <pre><code class="language-javascript">
// src/components/Maze.jsx

function Cell(i, j, size, cols, rows) {
  this.i = i;
  this.j = j;
  this.walls = [true, true, true, true]; // [Oben, Rechts, Unten, Links]
  this.visited = false;
  
  // Methode: Unbesuchte Nachbarn suchen
  this.checkNeighbors = function (cells) {
    const neighbors = [];
    // ... Logik um Nachbarn zu finden
    
    // Gibt zufälligen Nachbarn zurück
    if (neighbors.length > 0) {
      return neighbors[Math.floor(Math.random() * neighbors.length)];
    }
    return undefined;
  };

  this.draw = function (ctx) {
    // Nur aktive Wände zeichnen
    if (this.walls[0]) { ctx.moveTo(x, y); ctx.lineTo(x + size, y); } // Oben
    if (this.walls[1]) { ctx.moveTo(x + size, y); ctx.lineTo(x + size, y + size); } // Rechts
    // ... usw.
  };
}
                    </code></pre>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>5. Rendering & Optimierung</h1>
                <p>Implementierung von <strong>Offscreen Canvas</strong> (Double Buffer).</p>
                <p>Das statische Labyrinth wird nur EINMAL in den Speicher gezeichnet. In jedem Frame wird dieses Bild
                    kopiert und nur der Spieler neu gezeichnet. Dies verbessert die Performance drastisch.</p>
            </div>
            <div class="visual-panel">
                <div class="code-panel">
                    <div class="code-header">
                        <div class="dot red"></div>
                        <div class="dot yellow"></div>
                        <div class="dot green"></div>
                    </div>
                    <pre><code class="language-javascript">
// src/components/Maze.jsx

const drawMazeToOffscreen = useCallback((cols, rows, cellsArray) => {
  // ... Konfiguration des Offscreen-Canvas
  
  // Alle Zellen EINMAL zeichnen
  for (const cell of cellsArray) {
      cell.draw(offCtx);
  }
}, []);

const redrawAll = useCallback(() => {
  const ctx = ctxRef.current; // Sichtbares Canvas
  
  // Canvas leeren
  ctx.clearRect(0, 0, width, height);
  
  // Statisches Bild kopieren
  if (offscreenCanvasRef.current) {
    ctx.drawImage(offscreenCanvasRef.current, 0, 0, width, height);
  }
}, []);
                    </code></pre>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>6. Sprachsteuerung (WebSpeech API)</h1>
                <p>Integration der nativen Browser-API für Barrierefreiheit.</p>
                <p>Konfiguriert für kontinuierliche Erkennung. Das <code>transcript</code> wird in Echtzeit erfasst und
                    an den Befehlsprozessor gesendet.</p>
            </div>
            <div class="visual-panel">
                <div class="code-panel">
                    <div class="code-header">
                        <div class="dot red"></div>
                        <div class="dot yellow"></div>
                        <div class="dot green"></div>
                    </div>
                    <pre><code class="language-javascript">
// src/hooks/useVoiceControl.js

// Grundlegende Konfiguration
const recognition = new SpeechRecognition();
recognition.lang = lang;
recognition.continuous = true;
recognition.interimResults = false;

recognition.onresult = (event) => {
    const lastResult = event.results[event.results.length - 1];
    const transcript = lastResult[0].transcript;
    // Callback mit erkanntem Text
    onResult({ transcript, confidence: lastResult[0].confidence });
};
                    </code></pre>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>7. Interpretation (Regex)</h1>
                <p>Verarbeitung natürlicher Sprache.</p>
                <p>Wir nutzen <strong>Reguläre Ausdrücke</strong>, um Zahlen (z.B. "drei") und Befehle zu extrahieren.
                    Ermöglicht komplexe Befehle wie "Drei mal oben".</p>
            </div>
            <div class="visual-panel">
                <div class="code-panel">
                    <div class="code-header">
                        <div class="dot red"></div>
                        <div class="dot yellow"></div>
                        <div class="dot green"></div>
                    </div>
                    <pre><code class="language-javascript">
// src/utils/voiceCommandsMap.js

export function interpretSequence(transcript = "") {
    // Zahlen und Befehle erkennen
    const numMatch = part.match(/\b(\d+|uno|dos|three|four...)\b/);
    
    // Wenn Zahl, Wiederholungen setzen
    if (numMatch) repeat = parseNumberToken(numMatch[1]) || 1;

    // Nach Richtungswörtern suchen
    for (const w of words) {
        const cmd = interpretVoiceCommand(w); // Gibt "UP", "DOWN" usw.
        if (cmd) found.push(cmd);
    }
    
    // Befehle vervielfachen
    for (let r = 0; r < repeat; r++) {
        out.push(...found);
    }
    return out;
}
                    </code></pre>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>Geplante Evaluierung & User Testing</h1>
                <p>Wir planen eine quantitative Umfrage, um das System zu validieren.</p>

                <h2>Struktur der Umfrage</h2>
                <p><strong>30 Fragen</strong> in 4 Hauptkategorien (Skala 1-5):</p>
                <ol>
                    <li><strong>Design & Visuelles Feedback:</strong> Übersichtlichkeit, Icons, Kontrast.</li>
                    <li><strong>Bedienbarkeit & Technik:</strong> Stabilität, Menüführung, Performance.</li>
                    <li><strong>Sprachsteuerung:</strong> Erkennungsrate, Intuitivität der Befehle.</li>
                    <li><strong>Gesamteindruck:</strong> Spielspaß und Lernkurve.</li>
                </ol>

                <p style="margin-top:20px; color:var(--accent);">Nehmen Sie an der Umfrage teil:</p>
                <a href="https://forms.gle/rvwf2fAKFqTZm2nk6" class="btn-primary" <i class="fas fa-poll-h"></i> Zur
                    Umfrage
                </a>
            </div>
            <div class="visual-panel">
                <div class="qr-panel">
                    <img src="https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=https://forms.gle/rvwf2fAKFqTZm2nk6"
                        class="qr-img" alt="Umfrage QR">
                    <p class="qr-caption">Zur Umfrage</p>
                </div>
            </div>
        </div>

        <div class="slide split-content">
            <div class="content-panel">
                <h1>Vielen Dank!</h1>
                <p>Das Projekt ist live verfügbar.</p>
                <p>Testen Sie Ihre Fähigkeiten und die Sprachsteuerung direkt im Browser.</p>

                <a href="https://lenis-jf.github.io/voice-controlled-maze/" target="_blank" class="btn-primary">
                    <i class="fas fa-play"></i> Jetzt Spielen
                </a>
            </div>
            <div class="visual-panel">
                <div class="qr-panel">
                    <img src="https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=https://lenis-jf.github.io/voice-controlled-maze/"
                        class="qr-img" alt="Spiel QR Code">
                    <p class="qr-caption play-caption">Scannen zum Spielen</p>
                </div>
            </div>
        </div>

        <div class="slide-counter">Folie <span id="current">1</span> / <span id="total">14</span></div>

        <div class="controls">
            <button class="nav-btn" onclick="prevSlide()">← Zurück</button>
            <button class="nav-btn" onclick="nextSlide()">Weiter →</button>
        </div>
    </div>

    <!-- Slide Navigation Menu -->
    <div class="menu-toggle" id="menuToggle">
        <i class="fas fa-th-large"></i>
    </div>

    <div class="slide-nav-menu" id="slideNavMenu">
        <div class="menu-header">
            <h3>Slides Preview</h3>
            <button class="close-menu" id="closeMenu"><i class="fas fa-times"></i></button>
        </div>
        <div class="menu-items-container" id="menuItemsContainer">
            <!-- Items injected by JS -->
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>
    <script src="script.js?v=3.0"></script>

</body>

</html>