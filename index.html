<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voice Controlled Maze - HMI Präsentation</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600;700&family=Fira+Code:wght@400;500&display=swap"
        rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">

    <style>
        :root {
            --bg-color: #0a0f1d;
            --accent: #00e1ff;
            --accent-hover: #00b8d4;
            --text: #e2e8f0;
            --text-muted: #94a3b8;
            --glass-bg: rgba(20, 25, 40, 0.75);
            --glass-border: rgba(255, 255, 255, 0.08);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: var(--bg-color);
            background-image:
                radial-gradient(circle at 10% 20%, rgba(0, 225, 255, 0.1) 0%, transparent 40%),
                radial-gradient(circle at 90% 80%, rgba(139, 92, 246, 0.1) 0%, transparent 40%);
            color: var(--text);
            font-family: 'Inter', sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            perspective: 1000px;
        }

        .presentation-container {
            width: 95%;
            max-width: 1600px;
            height: 90vh;
            position: relative;
        }

        /* --- SLIDES --- */
        .slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: 1fr 1.5fr;
            gap: 2rem;
            padding: 2.5rem;
            background: var(--glass-bg);
            border-radius: 24px;
            box-shadow:
                0 20px 50px -10px rgba(0, 0, 0, 0.5),
                inset 0 0 20px rgba(255, 255, 255, 0.02);
            backdrop-filter: blur(16px) saturate(120%);
            border: 1px solid var(--glass-border);

            /* Animaciones */
            opacity: 0;
            visibility: hidden;
            transform: translateY(40px) scale(0.96) rotateX(4deg);
            pointer-events: none;
            transition: all 0.7s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        .slide.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0) scale(1) rotateX(0deg);
            z-index: 10;
            pointer-events: auto;
            transition-delay: 0.1s;
        }

        .slide.full-content {
            grid-template-columns: 1fr;
            text-align: center;
            align-content: center;
        }

        .slide.split-content {
            grid-template-columns: 1fr 1fr;
            text-align: left;
        }

        /* --- TEXT CONTENT --- */
        .content-panel {
            display: flex;
            flex-direction: column;
            justify-content: center;
            overflow-y: auto;
            padding-right: 10px;
            /* Evita que el scroll tape texto */
        }

        h1 {
            font-size: 2.2rem;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 1.5rem;
            line-height: 1.1;
            text-shadow: 0 0 20px rgba(0, 225, 255, 0.3);
        }

        h2 {
            font-size: 1.2rem;
            color: var(--text);
            margin-bottom: 0.8rem;
            font-weight: 600;
            border-bottom: 1px solid var(--glass-border);
            padding-bottom: 0.5rem;
        }

        p,
        li {
            font-size: 1rem;
            line-height: 1.6;
            color: var(--text-muted);
            margin-bottom: 1rem;
        }

        ul {
            list-style-position: inside;
            margin-bottom: 1rem;
        }

        strong {
            color: var(--text);
            font-weight: 600;
        }

        .authors {
            margin-top: 2rem;
            padding-top: 1rem;
            border-top: 1px solid var(--glass-border);
            font-size: 0.9rem;
            color: var(--text-muted);
        }

        /* --- VISUAL PANELS (Code & QR) --- */
        .visual-panel {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .code-panel {
            background: #121212;
            border-radius: 16px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.6), 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid #2a2a2a;
            width: 100%;
            height: 100%;
        }

        .code-header {
            background: #1a1a1a;
            padding: 10px 15px;
            display: flex;
            gap: 8px;
            border-bottom: 1px solid #2a2a2a;
            align-items: center;
            flex-shrink: 0;
        }

        .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
        }

        .red {
            background: #ff5f56;
        }

        .yellow {
            background: #ffbd2e;
        }

        .green {
            background: #27c93f;
        }

        pre {
            margin: 0 !important;
            height: 100%;
            overflow: auto !important;
            padding: 1.5rem !important;
            font-family: 'Fira Code', monospace !important;
            font-size: 0.9rem;
            line-height: 1.5 !important;
        }

        /* QR Panels */
        .qr-panel {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
            background: rgba(255, 255, 255, 0.03);
            padding: 30px;
            border-radius: 20px;
            border: 1px solid var(--glass-border);
        }

        .qr-img {
            width: 220px;
            height: 220px;
            border-radius: 12px;
            border: 8px solid white;
        }

        /* --- BUTTONS --- */
        .btn-primary {
            display: inline-flex;
            align-items: center;
            gap: 10px;
            background: var(--accent);
            color: #000;
            padding: 12px 25px;
            border-radius: 12px;
            font-weight: 700;
            text-decoration: none;
            transition: all 0.3s ease;
            box-shadow: 0 0 20px rgba(0, 225, 255, 0.4);
            border: none;
            cursor: pointer;
            font-size: 1rem;
            margin-top: 15px;
        }

        .btn-primary:hover {
            background: #fff;
            transform: translateY(-3px);
            box-shadow: 0 0 30px rgba(0, 225, 255, 0.6);
        }

        /* --- CONTROLS & COUNTER --- */
        .controls {
            position: absolute;
            bottom: 30px;
            right: 40px;
            display: flex;
            gap: 20px;
            z-index: 20;
        }

        .nav-btn {
            background: transparent;
            border: 2px solid var(--accent);
            padding: 10px 24px;
            border-radius: 12px;
            color: var(--accent);
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .nav-btn:hover {
            background: var(--accent);
            color: var(--bg-color);
        }

        .slide-counter {
            position: absolute;
            bottom: 45px;
            left: 50px;
            z-index: 30;
            font-family: 'Fira Code', monospace;
            color: var(--accent);
            background: rgba(0, 0, 0, 0.7);
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid rgba(0, 225, 255, 0.2);
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.3s ease, transform 0.3s ease;
            pointer-events: none;
        }

        .slide-counter.visible {
            opacity: 1;
            transform: translateY(0);
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-thumb {
            background: #334155;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        /* Responsive Fixes */
        @media (max-width: 900px) {
            .slide {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
                padding: 1.5rem;
                overflow-y: auto;
                /* Permitir scroll en la slide entera */
            }

            .slide.split-content {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 1.6rem;
            }

            /* Ajuste crítico para el código en móviles */
            .visual-panel {
                min-height: 50vh;
                /* Altura mínima para ver código */
                margin-bottom: 80px;
                /* Espacio para controles */
                align-items: flex-start;
                /* Alinear arriba */
            }

            .code-panel {
                height: 100%;
                max-height: 60vh;
                /* Limitar altura máxima */
            }

            pre {
                font-size: 0.9rem !important;
                /* Fuente legible */
                line-height: 1.6 !important;
                /* Más espacio entre líneas */
                padding: 1rem !important;
            }

            .controls {
                bottom: 15px;
                right: 20px;
            }

            .slide-counter {
                bottom: 20px;
                left: 20px;
            }

            .nav-btn {
                padding: 8px 16px;
                font-size: 0.9rem;
            }
        }
    </style>
</head>

<body>

    <div class="presentation-container">

        <div class="slide active split-content">
            <div class="content-panel">
                <h1>Voice Controlled Maze</h1>
                <p>Human Machine Interaction (HMI) Projekt</p>
                <p>Eine moderne Webanwendung, die Sprachsteuerung mit klassischen Labyrinth-Algorithmen verbindet.</p>

                <div class="authors">
                    <p><strong>Entwickelt von:</strong><br>
                        Juan Fernando Lenis Serna<br>
                        Ayman Lahseb</p>
                </div>
            </div>
            <div class="visual-panel">
                <div class="qr-panel">
                    <img src="https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=https://lenis-jf.github.io/voice-maze-presentation/"
                        class="qr-img" alt="Präsentation QR">
                    <p style="color:var(--text-muted); font-size:0.9rem; margin-top:10px;">Scannen für Slides</p>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>Projektziele & Umfang</h1>
                <h2>Das Hauptziel</h2>
                <p>Entwicklung einer <strong>barrierefreien, modernen und responsiven</strong> Webanwendung für
                    jedermann.</p>

                <h2>Kernfunktionen</h2>
                <ul>
                    <li><strong>Zufällige Generierung:</strong> Jedes Spiel ist einzigartig (Algorithmus-basiert).</li>
                    <li><strong>Anpassbar:</strong> Benutzerdefiniertes Raster (Grid-Size).</li>
                    <li><strong>Visuelles Feedback:</strong> Konstante Rückmeldung über den Spielstatus.</li>
                    <li><strong>Engagement:</strong> Fördert kontinuierliche Verbesserung des Spielers.</li>
                </ul>

                <h2>Steuerung & Accessibility</h2>
                <p>Unterstützt multimodale Eingaben (Tastatur & Stimme). Auf Mobilgeräten kommen <strong>Floating
                        Buttons</strong> zum Einsatz, um die Bewegung des Charakters präzise zu steuern.</p>
            </div>
            <div class="visual-panel">
                <div class="qr-panel" style="border:none; background:transparent;">
                    <i class="fas fa-universal-access"
                        style="font-size: 8rem; color: var(--accent); text-shadow: 0 0 30px rgba(0, 225, 255, 0.4);"></i>
                    <p style="margin-top:20px; text-align:center;">Unterstützung der Barrierefreiheit durch universelle
                        Eingabemethoden.</p>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>Warum ist das ein gutes HMI-Projekt?</h1>

                <p><strong>Natürliche Interaktion (NUI):</strong><br>
                    Ermöglicht durch Sprachsteuerung. Die Schnittstelle passt sich dem Menschen an, nicht umgekehrt.</p>

                <p><strong>Software-Ergonomie:</strong><br>
                    Das System ist leicht erlernbar und intuitiv zu bedienen. Es erfordert keine komplexe Einarbeitung.
                </p>

                <p><strong>System-Feedback & Status:</strong><br>
                    Auch wenn die Sprachverarbeitung Zeit benötigt, gibt das System visuelles Feedback (z.B.
                    "Listening..."), um die Latenz für den Nutzer transparent zu machen.</p>

                <p><strong>Multimodale Eingabe:</strong><br>
                    Kombination aus diskreten (Tastatur/Touch) und kontinuierlichen (Sprache) Eingabemethoden.</p>
            </div>
            <div class="visual-panel">
                <div class="qr-panel" style="border:none; background:transparent;">
                    <i class="fas fa-microphone-lines" style="font-size: 8rem; color: var(--text-muted);"></i>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>1. Algorithmus: BFS (Farthest Cell)</h1>
                <p>Wir nutzen eine <strong>Breitensuche (BFS)</strong>, um das gesamte Labyrinth vom Startpunkt aus zu
                    durchqueren.</p>
                <p>Dabei wird die Distanz zu jeder Zelle berechnet. Die Zelle mit der maximalen Distanz wird automatisch
                    als "Exit" (Ziel) definiert. Dies garantiert, dass das Ziel immer an einer herausfordernden Position
                    liegt.</p>
            </div>
            <div class="visual-panel">
                <div class="code-panel">
                    <div class="code-header">
                        <div class="dot red"></div>
                        <div class="dot yellow"></div>
                        <div class="dot green"></div>
                    </div>
                    <pre><code class="language-javascript">
// src/components/Maze.jsx

function bfs(startCell, cells) {
  // Distanzen zurücksetzen
  for (let cell of cells) {
    cell.distanceToStart = Infinity;
    cell.isExit = false;
  }
  const queue = [startCell];
  const localVisited = new Set([startCell]);
  startCell.distanceToStart = 0;

  while (queue.length > 0) {
    const currentCell = queue.shift();
    // findNeighborsBFS gibt erreichbare Nachbarn zurück 
    // (ohne Wände dazwischen)
    for (let neighbor of findNeighborsBFS(currentCell, cells)) {
      if (!localVisited.has(neighbor)) {
        localVisited.add(neighbor);
        queue.push(neighbor);
        neighbor.distanceToStart = currentCell.distanceToStart + 1;
      }
    }
  }
}

function findLongestPath(cells) {
  let maxDistance = -1;
  let exitCell = null;
  for (let cell of cells) {
    if (cell.distanceToStart !== Infinity && 
        cell.distanceToStart > maxDistance) {
      maxDistance = cell.distanceToStart;
      exitCell = cell;
    }
  }
  return exitCell;
}
                    </code></pre>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>2. Generierung: Backtracking</h1>
                <p>Das Herzstück der Labyrinth-Erstellung. Wir verwenden <strong>Iteratives Backtracking</strong> mit
                    einem Stack.</p>
                <p>Der Algorithmus besucht eine Zelle, wählt einen zufälligen Nachbarn, durchbricht die Wand und rückt
                    vor. Wenn es keine Nachbarn gibt, geht er zurück (Stack Pop), bis ein neuer Weg gefunden wird.</p>
            </div>
            <div class="visual-panel">
                <div class="code-panel">
                    <div class="code-header">
                        <div class="dot red"></div>
                        <div class="dot yellow"></div>
                        <div class="dot green"></div>
                    </div>
                    <pre><code class="language-javascript">
// src/components/Maze.jsx (innerhalb der Animationsschleife)

// DFS-Algorithmus (Backtracking)
if (localCurrent) {
  const next = localCurrent.checkNeighbors(localCells);
  if (next) {
    next.visited = true;
    
    // Zum Stack hinzufügen für Rückweg
    localStack.push(localCurrent);
    
    // Wände zwischen Zellen entfernen
    removeWalls(localCurrent, next);
    
    // Zeiger bewegen
    localCurrent = next;
  } else if (localStack.length > 0) {
    // Wenn keine Nachbarn, Backtracking
    localCurrent = localStack.pop();
  }
}
                    </code></pre>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>3. Spielerlogik (Klasse Player)</h1>
                <p>Die Klasse <code>Player</code> kapselt die Physik und die interpolierte Bewegung.</p>
                <p>Hervorzuheben ist die Methode <code>update</code>, die <strong>easeOutSine</strong> für weiche
                    Bewegungen nutzt, sowie eine "Bounce"-Logik für visuelles Feedback bei Kollisionen.</p>
            </div>
            <div class="visual-panel">
                <div class="code-panel">
                    <div class="code-header">
                        <div class="dot red"></div>
                        <div class="dot yellow"></div>
                        <div class="dot green"></div>
                    </div>
                    <pre><code class="language-javascript">
// src/components/Player.js

export default class Player {
  constructor(startCell, cellSize, options = {}) {
    this.cellSize = cellSize;
    this.setPositionFromCell(startCell);
    // ... Initialisierung von Zustandsvariablen
  }

  // update wird jeden Frame aufgerufen
  update(dt) {
    // Weiche Bewegung zwischen Positionen
    if (this.progress < 1) {
      this.elapsed += dt;
      const t = Math.min(1, this.elapsed / this.moveDuration);
      const eased = easeOutSine(t);
      
      // Lineare Interpolation
      this.x = lerp(this.startPos.x, this.endPos.x, eased);
      this.y = lerp(this.startPos.y, this.endPos.y, eased);
      this.progress = t;
    }

    // Unabhängige Logik für Kollisionen
    if (this.bouncing) {
      // ... Berechnungen für visuellen Aufprall
    }
  }
  
  // ... Methoden moveTo, draw, etc.
}
                    </code></pre>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>4. Klasse Zelle (Cell)</h1>
                <p>Die fundamentale Einheit des Rasters.</p>
                <p>Sie verwaltet Position, Zustand (visited, start, exit) und die <strong>4 Wände</strong>. Enthält auch
                    die <code>checkNeighbors</code> Logik für die Zufallsgenerierung.</p>
            </div>
            <div class="visual-panel">
                <div class="code-panel">
                    <div class="code-header">
                        <div class="dot red"></div>
                        <div class="dot yellow"></div>
                        <div class="dot green"></div>
                    </div>
                    <pre><code class="language-javascript">
// src/components/Maze.jsx

function Cell(i, j, size, cols, rows) {
  this.i = i;
  this.j = j;
  this.walls = [true, true, true, true]; // [Oben, Rechts, Unten, Links]
  this.visited = false;
  
  // Methode: Unbesuchte Nachbarn suchen
  this.checkNeighbors = function (cells) {
    const neighbors = [];
    // ... Logik um Nachbarn zu finden
    
    // Gibt zufälligen Nachbarn zurück
    if (neighbors.length > 0) {
      return neighbors[Math.floor(Math.random() * neighbors.length)];
    }
    return undefined;
  };

  this.draw = function (ctx) {
    // Nur aktive Wände zeichnen
    if (this.walls[0]) { ctx.moveTo(x, y); ctx.lineTo(x + size, y); } // Oben
    if (this.walls[1]) { ctx.moveTo(x + size, y); ctx.lineTo(x + size, y + size); } // Rechts
    // ... usw.
  };
}
                    </code></pre>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>5. Rendering & Optimierung</h1>
                <p>Implementierung von <strong>Offscreen Canvas</strong> (Double Buffer).</p>
                <p>Das statische Labyrinth wird nur EINMAL in den Speicher gezeichnet. In jedem Frame wird dieses Bild
                    kopiert und nur der Spieler neu gezeichnet. Dies verbessert die Performance drastisch.</p>
            </div>
            <div class="visual-panel">
                <div class="code-panel">
                    <div class="code-header">
                        <div class="dot red"></div>
                        <div class="dot yellow"></div>
                        <div class="dot green"></div>
                    </div>
                    <pre><code class="language-javascript">
// src/components/Maze.jsx

const drawMazeToOffscreen = useCallback((cols, rows, cellsArray) => {
  // ... Konfiguration des Offscreen-Canvas
  
  // Alle Zellen EINMAL zeichnen
  for (const cell of cellsArray) {
      cell.draw(offCtx);
  }
}, []);

const redrawAll = useCallback(() => {
  const ctx = ctxRef.current; // Sichtbares Canvas
  
  // Canvas leeren
  ctx.clearRect(0, 0, width, height);
  
  // Statisches Bild kopieren
  if (offscreenCanvasRef.current) {
    ctx.drawImage(offscreenCanvasRef.current, 0, 0, width, height);
  }
}, []);
                    </code></pre>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>6. Sprachsteuerung (WebSpeech API)</h1>
                <p>Integration der nativen Browser-API für Barrierefreiheit.</p>
                <p>Konfiguriert für kontinuierliche Erkennung. Das <code>transcript</code> wird in Echtzeit erfasst und
                    an den Befehlsprozessor gesendet.</p>
            </div>
            <div class="visual-panel">
                <div class="code-panel">
                    <div class="code-header">
                        <div class="dot red"></div>
                        <div class="dot yellow"></div>
                        <div class="dot green"></div>
                    </div>
                    <pre><code class="language-javascript">
// src/hooks/useVoiceControl.js

// Grundlegende Konfiguration
const recognition = new SpeechRecognition();
recognition.lang = lang;
recognition.continuous = true;
recognition.interimResults = false;

recognition.onresult = (event) => {
    const lastResult = event.results[event.results.length - 1];
    const transcript = lastResult[0].transcript;
    // Callback mit erkanntem Text
    onResult({ transcript, confidence: lastResult[0].confidence });
};
                    </code></pre>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>7. Interpretation (Regex)</h1>
                <p>Verarbeitung natürlicher Sprache.</p>
                <p>Wir nutzen <strong>Reguläre Ausdrücke</strong>, um Zahlen (z.B. "drei") und Befehle zu extrahieren.
                    Ermöglicht komplexe Befehle wie "Drei mal oben".</p>
            </div>
            <div class="visual-panel">
                <div class="code-panel">
                    <div class="code-header">
                        <div class="dot red"></div>
                        <div class="dot yellow"></div>
                        <div class="dot green"></div>
                    </div>
                    <pre><code class="language-javascript">
// src/utils/voiceCommandsMap.js

export function interpretSequence(transcript = "") {
    // Zahlen und Befehle erkennen
    const numMatch = part.match(/\b(\d+|uno|dos|three|four...)\b/);
    
    // Wenn Zahl, Wiederholungen setzen
    if (numMatch) repeat = parseNumberToken(numMatch[1]) || 1;

    // Nach Richtungswörtern suchen
    for (const w of words) {
        const cmd = interpretVoiceCommand(w); // Gibt "UP", "DOWN" usw.
        if (cmd) found.push(cmd);
    }
    
    // Befehle vervielfachen
    for (let r = 0; r < repeat; r++) {
        out.push(...found);
    }
    return out;
}
                    </code></pre>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>GOMS-CMN Analyse</h1>
                <p>Modellierung der Benutzerinteraktion für die Aufgabe "Labyrinth lösen".</p>

                <h2>Goals & Methods</h2>
                <ul>
                    <li><strong>GOAL:</strong> Solve Maze</li>
                    <li><strong>METHOD 1:</strong> Use Voice Control (Say "Up", "Down")</li>
                    <li><strong>METHOD 2:</strong> Use Keyboard (WASD / Arrows)</li>
                    <li><strong>METHOD 3:</strong> Use Touch Buttons</li>
                </ul>

                <h2>Selection Rules (Beispiel)</h2>
                <p><em>RULE 1:</em> Select USE-KEYBOARD if no microphone is available.<br>
                    <em>RULE 2:</em> Select USE-TOUCH if mobile device is detected.
                </p>
            </div>
            <div class="visual-panel">
                <div class="code-panel">
                    <div class="code-header">
                        <div class="dot red"></div>
                        <div class="dot yellow"></div>
                        <div class="dot green"></div>
                    </div>
                    <pre><code class="language-javascript">
GOAL: SOLVE-MAZE-USING-VOICE-CONTROL
    GOAL: ENABLE-VOICE-CONTROL
        MOVE-MOUSE-TO-MICROPHONE-BUTTON
        CLICK-LEFT-MOUSE-BUTTON
    GOAL: NAVIGATE
        SAY-VOICE-COMMAND('UP'/'DOWN'/'RIGHT'/'LEFT')
        VERIFY-MOVEMENT-FEEDBACK
        REPEAT-UNTIL-EXIT
                    </code></pre>
                </div>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>Geplante Evaluierung & User Testing</h1>
                <p>Wir planen eine quantitative Umfrage, um das System zu validieren.</p>

                <h2>Struktur der Umfrage</h2>
                <p><strong>30 Fragen</strong> in 4 Hauptkategorien (Skala 1-5):</p>
                <ol>
                    <li><strong>Design & Visuelles Feedback:</strong> Übersichtlichkeit, Icons, Kontrast.</li>
                    <li><strong>Bedienbarkeit & Technik:</strong> Stabilität, Menüführung, Performance.</li>
                    <li><strong>Sprachsteuerung:</strong> Erkennungsrate, Intuitivität der Befehle.</li>
                    <li><strong>Gesamteindruck:</strong> Spielspaß und Lernkurve.</li>
                </ol>

                <p style="margin-top:20px; color:var(--accent);">Nehmen Sie an der Umfrage teil:</p>
                <a href="#ENCUESTA_PENDIENTE" class="btn-primary"
                    onclick="alert('Link zur Umfrage noch nicht verfügbar.'); return false;">
                    <i class="fas fa-poll-h"></i> Zur Umfrage
                </a>
            </div>
            <div class="visual-panel">
                <div class="qr-panel">
                    <img src="https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=EncuestaPendiente"
                        class="qr-img" alt="Umfrage QR">
                    <p style="color:var(--text-muted); font-size:0.9rem; margin-top:10px;">Scan to Evaluate</p>
                </div>
            </div>
        </div>

        <div class="slide split-content">
            <div class="content-panel">
                <h1>Vielen Dank!</h1>
                <p>Das Projekt ist live verfügbar.</p>
                <p>Testen Sie Ihre Fähigkeiten und die Sprachsteuerung direkt im Browser.</p>

                <a href="https://lenis-jf.github.io/voice-controlled-maze/" target="_blank" class="btn-primary">
                    <i class="fas fa-play"></i> Jetzt Spielen
                </a>
            </div>
            <div class="visual-panel">
                <div class="qr-panel">
                    <img src="https://api.qrserver.com/v1/create-qr-code/?size=300x300&data=https://lenis-jf.github.io/voice-controlled-maze/"
                        class="qr-img" alt="Spiel QR Code">
                    <p style="color:var(--accent); margin-top:10px; font-family:'Fira Code'">Scan to Play</p>
                </div>
            </div>
        </div>

        <div class="slide-counter">Folie <span id="current">1</span> / <span id="total">13</span></div>

        <div class="controls">
            <button class="nav-btn" onclick="prevSlide()">← Zurück</button>
            <button class="nav-btn" onclick="nextSlide()">Weiter →</button>
        </div>
    </div>

    <script>
        let currentSlide = 0;
        const slides = document.querySelectorAll('.slide');
        const counterCurrent = document.getElementById('current');
        const counterTotal = document.getElementById('total');
        const counterEl = document.querySelector('.slide-counter');
        let hideTimer;

        // Inicializar total dinámicamente
        counterTotal.innerText = slides.length;

        function showCounter() {
            counterEl.classList.add('visible');
            if (hideTimer) clearTimeout(hideTimer);
            hideTimer = setTimeout(() => {
                counterEl.classList.remove('visible');
            }, 3000);
        }

        function showSlide(index) {
            slides.forEach((slide, i) => {
                slide.classList.toggle('active', i === index);
            });
            counterCurrent.innerText = index + 1;
            showCounter();
        }

        function nextSlide() {
            if (currentSlide < slides.length - 1) {
                currentSlide++;
                showSlide(currentSlide);
            }
        }

        function prevSlide() {
            if (currentSlide > 0) {
                currentSlide--;
                showSlide(currentSlide);
            }
        }

        // Teclado
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' || e.key === ' ') nextSlide();
            if (e.key === 'ArrowLeft') prevSlide();
        });

        // Mostrar contador inicial
        showCounter();
    </script>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>

</body>

</html>