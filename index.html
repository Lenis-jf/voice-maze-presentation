<!DOCTYPE html>
<html lang="de">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Project Präsentation</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&family=Fira+Code:wght@400;500&display=swap"
        rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css" rel="stylesheet" />

    <style>
        :root {
            --bg-color: #0a0f1d;
            --accent: #00e1ff;
            --text: #e2e8f0;
            --text-muted: #94a3b8;
            --glass-bg: rgba(20, 25, 40, 0.75);
            --glass-border: rgba(255, 255, 255, 0.08);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background-color: var(--bg-color);
            background-image:
                radial-gradient(circle at 10% 20%, rgba(0, 225, 255, 0.1) 0%, transparent 40%),
                radial-gradient(circle at 90% 80%, rgba(139, 92, 246, 0.1) 0%, transparent 40%);
            color: var(--text);
            font-family: 'Inter', sans-serif;
            height: 100vh;
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            perspective: 1000px;
        }

        .presentation-container {
            width: 92%;
            max-width: 1400px;
            height: 88vh;
            position: relative;
        }

        .slide {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: grid;
            grid-template-columns: 1fr 1.4fr;
            gap: 3rem;
            padding: 2.5rem;
            background: var(--glass-bg);
            border-radius: 24px;
            box-shadow:
                0 20px 50px -10px rgba(0, 0, 0, 0.5),
                inset 0 0 20px rgba(255, 255, 255, 0.02);
            backdrop-filter: blur(16px) saturate(120%);
            border: 1px solid var(--glass-border);
            opacity: 0;
            visibility: hidden;
            transform: translateY(40px) scale(0.96) rotateX(4deg);
            pointer-events: none;
            transition: all 0.7s cubic-bezier(0.2, 0.8, 0.2, 1);
        }

        .slide.active {
            opacity: 1;
            visibility: visible;
            transform: translateY(0) scale(1) rotateX(0deg);
            z-index: 10;
            pointer-events: auto;
            transition-delay: 0.1s;
        }

        .content-panel {
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        h1 {
            font-size: 2.4rem;
            font-weight: 700;
            color: var(--accent);
            margin-bottom: 1.5rem;
            line-height: 1.1;
            letter-spacing: -0.5px;
            text-shadow: 0 0 15px rgba(0, 225, 255, 0.4);
        }

        p {
            font-size: 1.1rem;
            line-height: 1.7;
            color: var(--text-muted);
            margin-bottom: 1.2rem;
        }

        strong {
            color: var(--text);
            font-weight: 600;
        }

        .code-panel {
            background: #121212;
            border-radius: 16px;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            box-shadow: inset 0 0 30px rgba(0, 0, 0, 0.6), 0 10px 30px rgba(0, 0, 0, 0.3);
            border: 1px solid #2a2a2a;
            transform: translateZ(0);
        }

        .code-header {
            background: #1a1a1a;
            padding: 12px 18px;
            display: flex;
            gap: 8px;
            border-bottom: 1px solid #2a2a2a;
            align-items: center;
        }

        .dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            transition: filter 0.2s;
        }

        .red {
            background: #ff5f56;
        }

        .yellow {
            background: #ffbd2e;
        }

        .green {
            background: #27c93f;
        }

        .code-panel:hover .dot {
            filter: brightness(1.2);
        }

        pre {
            margin: 0 !important;
            height: 100%;
            overflow-y: auto !important;
            padding: 1.5rem !important;
            font-family: 'Fira Code', monospace !important;
            font-size: 0.95rem;
            line-height: 1.5 !important;
        }

        ::-webkit-scrollbar {
            width: 6px;
            height: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: #334155;
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }

        .controls {
            position: absolute;
            bottom: 30px;
            right: 40px;
            display: flex;
            gap: 20px;
            z-index: 20;
        }

        button {
            position: relative;
            background: transparent;
            border: 2px solid var(--accent);
            padding: 12px 28px;
            border-radius: 12px;
            color: var(--accent);
            font-weight: 600;
            font-family: 'Inter', sans-serif;
            font-size: 1rem;
            cursor: pointer;
            overflow: hidden;
            transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
            backdrop-filter: blur(5px);
        }

        button::after {
            content: '';
            position: absolute;
            top: -50%;
            left: -50%;
            width: 200%;
            height: 200%;
            background: linear-gradient(to bottom right,
                    rgba(255, 255, 255, 0) 0%,
                    rgba(255, 255, 255, 0.2) 50%,
                    rgba(255, 255, 255, 0) 100%);
            transform: rotate(45deg) translateY(-100%);
            transition: transform 0.4s ease-out;
            pointer-events: none;
        }

        button:hover {
            background: var(--accent);
            color: var(--bg-color);
            transform: translateY(-4px) scale(1.05);
            box-shadow:
                0 15px 30px -5px rgba(0, 225, 255, 0.5),
                0 0 15px var(--accent);
        }

        button:hover::after {
            transform: rotate(45deg) translateY(100%);
        }

        button:active {
            transform: translateY(-1px) scale(0.98);
            box-shadow: 0 5px 15px -5px rgba(0, 225, 255, 0.5);
        }

        /* --- CONTADOR CON ANIMACIÓN CSS (SOLUCIÓN DEFINITIVA) --- */
        .slide-counter {
            position: absolute;
            bottom: 45px;
            left: 50px;
            z-index: 30;
            font-family: 'Fira Code', monospace;
            color: var(--accent);
            font-size: 1rem;
            letter-spacing: 1px;
            background: rgba(0, 0, 0, 0.6);
            padding: 8px 16px;
            border-radius: 20px;
            border: 1px solid rgba(0, 225, 255, 0.2);

            /* Estado base: Oculto */
            opacity: 0;
            transform: translateY(10px);
            pointer-events: none;
        }

        /* Esta clase dispara la animación cuando JS la añade */
        .slide-counter.run-animation {
            animation: fadeCycle 3.5s ease forwards;
        }

        /* Definimos el ciclo exacto de vida del contador */
        @keyframes fadeCycle {
            0% {
                opacity: 0;
                transform: translateY(10px);
            }

            10% {
                opacity: 1;
                transform: translateY(0);
            }

            /* Aparece rápido */
            85% {
                opacity: 1;
                transform: translateY(0);
            }

            /* Se queda quieto hasta el 85% del tiempo */
            100% {
                opacity: 0;
                transform: translateY(10px);
            }

            /* Desaparece al final */
        }

        /* --- RESPONSIVE FIX (Para Celulares) --- */
        @media (max-width: 900px) {
            .slide {
                grid-template-columns: 1fr;
                grid-template-rows: auto 1fr;
                gap: 1.5rem;
                padding: 1.5rem;
                overflow-y: auto;
            }

            h1 {
                font-size: 1.8rem;
            }

            .code-panel {
                min-height: 400px;
                margin-bottom: 80px;
            }

            .controls {
                bottom: 15px;
                right: 20px;
                width: auto;
            }

            button {
                padding: 10px 20px;
                font-size: 0.9rem;
            }

            .slide-counter {
                bottom: 20px;
                left: 20px;
                font-size: 0.8rem;
            }
        }
    </style>
</head>

<body>

    <div class="presentation-container">

        <div class="slide active">
            <div class="content-panel">
                <h1>1. BFS-Algorithmus zum Finden des Ausgangs</h1>
                <p><strong>Strategie "Farthest Cell":</strong> Implementierung einer Breitensuche (BFS), um das gesamte
                    Labyrinth vom Startpunkt aus zu durchqueren.</p>
                <p>Wir berechnen die Distanz zu jeder Zelle und wählen die am weitesten entfernte als "Ausgang" (Exit).
                    Dies garantiert, dass sich das Ziel immer an einer für den Spieler herausfordernden Position
                    befindet.</p>
            </div>
            <div class="code-panel">
                <div class="code-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
                <pre><code class="language-javascript">
// src/components/Maze.jsx

function bfs(startCell, cells) {
  // Distanzen zurücksetzen
  for (let cell of cells) {
    cell.distanceToStart = Infinity;
    cell.isExit = false;
  }
  const queue = [startCell];
  const localVisited = new Set([startCell]);
  startCell.distanceToStart = 0;

  while (queue.length > 0) {
    const currentCell = queue.shift();
    // findNeighborsBFS gibt erreichbare Nachbarn zurück 
    // (ohne Wände dazwischen)
    for (let neighbor of findNeighborsBFS(currentCell, cells)) {
      if (!localVisited.has(neighbor)) {
        localVisited.add(neighbor);
        queue.push(neighbor);
        neighbor.distanceToStart = currentCell.distanceToStart + 1;
      }
    }
  }
}

function findLongestPath(cells) {
  let maxDistance = -1;
  let exitCell = null;
  for (let cell of cells) {
    if (cell.distanceToStart !== Infinity && 
        cell.distanceToStart > maxDistance) {
      maxDistance = cell.distanceToStart;
      exitCell = cell;
    }
  }
  return exitCell;
}
                </code></pre>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>2. Backtracking-Algorithmus (Generierung)</h1>
                <p><strong>Das Herzstück der Labyrinth-Erstellung.</strong></p>
                <p>Es wird eine iterative Backtracking-Technik mit einem Stack verwendet. Der Algorithmus besucht eine
                    Zelle, durchbricht Wände zu zufälligen Nachbarn und rückt vor. Wenn er keine Optionen mehr hat, geht
                    er zurück (Stack Pop), bis ein neuer Weg gefunden wird.</p>
            </div>
            <div class="code-panel">
                <div class="code-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
                <pre><code class="language-javascript">
// src/components/Maze.jsx (innerhalb der Animationsschleife)

// DFS-Algorithmus (Backtracking)
if (localCurrent) {
  const next = localCurrent.checkNeighbors(localCells);
  if (next) {
    next.visited = true;
    
    // Zum Stack hinzufügen, um "zurückkehren" zu können
    localStack.push(localCurrent);
    
    // Wände zwischen aktueller und nächster Zelle einreißen
    removeWalls(localCurrent, next);
    
    // Zeiger bewegen
    localCurrent = next;
  } else if (localStack.length > 0) {
    // Wenn keine Nachbarn vorhanden, zurückgehen (Backtracking)
    localCurrent = localStack.pop();
  }
}
                </code></pre>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>3. Spielerlogik (Klasse Player)</h1>
                <p>Die Klasse <code>Player</code> kapselt die Physik und die interpolierte Bewegung.</p>
                <p>Hervorzuheben ist die Methode <code>update</code>, die eine Easing-Funktion
                    (<strong>easeOutSine</strong>) verwendet, um die Bewegung zwischen den Zellen zu glätten, sowie eine
                    "Bounce"-Logik für visuelles Feedback bei Kollisionen mit Wänden.</p>
            </div>
            <div class="code-panel">
                <div class="code-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
                <pre><code class="language-javascript">
// src/components/Player.js

export default class Player {
  constructor(startCell, cellSize, options = {}) {
    this.cellSize = cellSize;
    this.setPositionFromCell(startCell);
    // ... Initialisierung von Zustandsvariablen
  }

  // update wird in jedem Frame der Spielschleife aufgerufen
  update(dt) {
    // Weiche Bewegung zwischen startPos und endPos
    if (this.progress < 1) {
      this.elapsed += dt;
      const t = Math.min(1, this.elapsed / this.moveDuration);
      const eased = easeOutSine(t);
      
      // Lineare Interpolation
      this.x = lerp(this.startPos.x, this.endPos.x, eased);
      this.y = lerp(this.startPos.y, this.endPos.y, eased);
      this.progress = t;
    }

    // Unabhängige Logik für den Abpralleffekt an Wänden
    if (this.bouncing) {
      // ... Berechnungen zur Simulation des visuellen Aufpralls
    }
  }
  // ... Methoden moveTo, draw, usw.
}
                </code></pre>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>4. Klasse Zelle (Cell)</h1>
                <p>Die fundamentale Einheit des Rasters.</p>
                <p>Sie verwaltet ihre Position, ihren Zustand (besucht, Start, Ende) und ihre <strong>4 Wände</strong>.
                    Sie enthält die Logik <code>checkNeighbors</code> für die zufällige Generierung und ihre eigene
                    Zeichenmethode für das Canvas.</p>
            </div>
            <div class="code-panel">
                <div class="code-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
                <pre><code class="language-javascript">
// src/components/Maze.jsx

function Cell(i, j, size, cols, rows) {
  this.i = i;
  this.j = j;
  this.walls = [true, true, true, true]; // [Oben, Rechts, Unten, Links]
  this.visited = false;
  
  // Methode zur Suche nach nicht besuchten Nachbarn
  this.checkNeighbors = function (cells) {
    const neighbors = [];
    // ... Logik zum Abrufen von Nachbarindizes
    
    // Gibt einen zufälligen Nachbarn zurück, falls vorhanden
    if (neighbors.length > 0) {
      return neighbors[Math.floor(Math.random() * neighbors.length)];
    }
    return undefined;
  };

  this.draw = function (ctx) {
    // Zeichnet nur die Wände, die 'true' sind
    if (this.walls[0]) { ctx.moveTo(x, y); ctx.lineTo(x + size, y); }
    if (this.walls[1]) { ctx.moveTo(x + size, y); ctx.lineTo(x + size, y + size); }
    // ... usw.
  };
}
                </code></pre>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>5. Optimierung (Offscreen Canvas)</h1>
                <p>Zur Vermeidung von Leistungsproblemen (niedrige FPS).</p>
                <p>Implementierung von <strong>Double Buffer</strong>. Das statische Labyrinth wird nur EINMAL in den
                    Speicher gezeichnet. In jedem Frame "kopieren" wir dieses Bild und zeichnen den Spieler darüber,
                    wodurch die Neuberechnung tausender Wände pro Sekunde vermieden wird.</p>
            </div>
            <div class="code-panel">
                <div class="code-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
                <pre><code class="language-javascript">
// src/components/Maze.jsx

const drawMazeToOffscreen = useCallback((cols, rows, cellsArray) => {
  // ... Konfiguration des Offscreen-Canvas
  
  // Wir zeichnen alle Zellen HIER nur EINMAL
  for (const cell of cellsArray) {
      cell.draw(offCtx);
  }
}, []);

const redrawAll = useCallback(() => {
  const ctx = ctxRef.current; // Sichtbares Canvas
  
  // Löschen
  ctx.clearRect(0, 0, width, height);
  
  // Kopieren des statischen Labyrinthbildes sofort
  if (offscreenCanvasRef.current) {
    ctx.drawImage(offscreenCanvasRef.current, 0, 0, width, height);
  }
}, []);
                </code></pre>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>6. Sprachsteuerung (WebSpeech API)</h1>
                <p>Native Browser-Integration für Barrierefreiheit und modernes Gameplay.</p>
                <p>Wir konfigurieren die kontinuierliche Erkennung und erfassen das <code>transcript</code> in Echtzeit,
                    um es an den Befehlsprozessor zu senden.</p>
            </div>
            <div class="code-panel">
                <div class="code-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
                <pre><code class="language-javascript">
// src/hooks/useVoiceControl.js

// Grundlegende Konfiguration der Erkennung
const recognition = new SpeechRecognition();
recognition.lang = lang;
recognition.continuous = true;
recognition.interimResults = false;

recognition.onresult = (event) => {
    const lastResult = event.results[event.results.length - 1];
    const transcript = lastResult[0].transcript;
    // Callback an die Hauptkomponente mit dem gehörten Text
    onResult({ transcript, confidence: lastResult[0].confidence });
};
                </code></pre>
            </div>
        </div>

        <div class="slide">
            <div class="content-panel">
                <h1>7. Interpretation mit Regex</h1>
                <p>Analyse natürlicher Sprache für komplexe Befehle.</p>
                <p>Wir verwenden <strong>Reguläre Ausdrücke</strong>, um Mengen ("zwei", "3") und Richtungen zu
                    extrahieren. Dies ermöglicht es dem Benutzer, "Dreimal hoch" zu sagen, und das System führt die
                    Aktion <code>UP</code> dreimal hintereinander aus.</p>
            </div>
            <div class="code-panel">
                <div class="code-header">
                    <div class="dot red"></div>
                    <div class="dot yellow"></div>
                    <div class="dot green"></div>
                </div>
                <pre><code class="language-javascript">
// src/utils/voiceCommandsMap.js

export function interpretSequence(transcript = "") {
    // Erkennen von Zahlen gefolgt von einem Befehl
    const numMatch = part.match(/\b(\d+|uno|dos|three|four...)\b/);
    
    // Wenn eine Zahl vorhanden ist, Wiederholungen festlegen
    if (numMatch) repeat = parseNumberToken(numMatch[1]) || 1;

    // Suche nach Richtungs-Schlüsselwörtern
    for (const w of words) {
        const cmd = interpretVoiceCommand(w); // Gibt "UP", "DOWN" zurück
        if (cmd) found.push(cmd);
    }
    
    // Multiplizieren der gefundenen Befehle
    for (let r = 0; r < repeat; r++) {
        out.push(...found);
    }
    return out;
}
                </code></pre>
            </div>
        </div>

        <div class="slide-counter">Folie <span id="current">1</span> / 7</div>

        <div class="controls">
            <button onclick="prevSlide()">← Zurück</button>
            <button onclick="nextSlide()">Weiter →</button>
        </div>
    </div>

    <script>
        let currentSlide = 0;
        const slides = document.querySelectorAll('.slide');
        const counter = document.getElementById('current');
        const counterEl = document.querySelector('.slide-counter');

        // Función corregida: Usamos el ciclo de animación CSS en lugar de JS Timers
        function showCounter() {
            // 1. Quitamos la clase de animación (para resetear si ya estaba corriendo)
            counterEl.classList.remove('run-animation');

            // 2. Truco mágico (Reflow): Forzamos al navegador a "darse cuenta" de que quitamos la clase.
            // Sin esto, el navegador optimiza y no reinicia la animación si sucede muy rápido.
            void counterEl.offsetWidth;

            // 3. Volvemos a añadir la clase para que la animación empiece de 0
            counterEl.classList.add('run-animation');
        }

        function showSlide(index) {
            slides.forEach((slide, i) => {
                slide.classList.toggle('active', i === index);
            });
            counter.innerText = index + 1;

            // Trigger del contador
            showCounter();
        }

        function nextSlide() {
            if (currentSlide < slides.length - 1) {
                currentSlide++;
                showSlide(currentSlide);
            }
        }

        function prevSlide() {
            if (currentSlide > 0) {
                currentSlide--;
                showSlide(currentSlide);
            }
        }

        // Navegación por teclado
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowRight' || e.key === ' ') nextSlide();
            if (e.key === 'ArrowLeft') prevSlide();
        });

        // Mostrar contador al cargar la página por primera vez
        showCounter();

    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-javascript.min.js"></script>

</body>

</html>